// Generated by CoffeeScript 1.9.1

/*
		Sapphire JavaScript Library
		http://code.google.com/p/jmodel/

		Copyright (c) 2009-2013 Richard Baker
		Dual licensed under the MIT and GPL licenses
 */
var slice = [].slice,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

define(['jmodel/opal2'], function() {
  var List, Map, Record, Set, Stream, Tuple;
  window.Tuple = Tuple = (function() {
    function Tuple() {}

    Tuple.prototype.constuctor = function() {
      var arg, args, i, len, results;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      results = [];
      for (i = 0, len = args.length; i < len; i++) {
        arg = args[i];
        results.push(Array.prototype.push.call(this, arg));
      }
      return results;
    };

    Tuple.equal = Function.From(Tuple, Tuple)(function(arg1, arg2) {
      var a, b;
      a = 1 <= arg1.length ? slice.call(arg1, 0) : [];
      b = 1 <= arg2.length ? slice.call(arg2, 0) : [];
      return Array.equal(a, b);
    });

    Tuple.Of = Function.Cache.From([Function]).To(Function)(function() {
      var constructors, types;
      constructors = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      types = constructors.map(function(constructor) {
        return Object.ensure(constructor);
      });
      return (function(superClass) {
        extend(_Class, superClass);

        function _Class() {
          var arg, args, i, len, ref, ref1, type;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          ref = Array.zip(types, args);
          for (i = 0, len = ref.length; i < len; i++) {
            ref1 = ref[i], type = ref1[0], arg = ref1[1];
            Array.prototype.push.call(this, type(arg));
          }
        }

        return _Class;

      })(this);
    });

    return Tuple;

  })();
  window.Set = Set = (function() {
    function Set(elements) {
      var element, i, len;
      if (elements == null) {
        elements = [];
      }
      if (typeof elements === 'string' || arguments.length > 1 || (elements.length == null)) {
        elements = Array.prototype.slice.call(arguments);
      }
      this.length = 0;
      for (i = 0, len = elements.length; i < len; i++) {
        element = elements[i];
        this.add(element);
      }
    }

    Set.prototype.add = Function.Chaining(function(element) {
      if (!this.member(element)) {
        return Array.prototype.push.call(this, element);
      }
    });

    Set.prototype.remove = Function.From(Maybe(Function))(function(predicate) {
      var element, partition, ref;
      if (predicate == null) {
        predicate = Boolean.True;
      }
      partition = this.partition(predicate);
      Array.prototype.splice.apply(this, [0, this.length].concat(slice.call((function() {
          var i, len, ref, ref1, results;
          ref1 = (ref = partition.get(false)) != null ? ref : [];
          results = [];
          for (i = 0, len = ref1.length; i < len; i++) {
            element = ref1[i];
            results.push(element);
          }
          return results;
        })())));
      return (ref = partition.get(true)) != null ? ref : new this.constructor;
    });

    Set.prototype.member = Predicate.From(Maybe(Value))(function(element) {
      return -1 !== Array.prototype.indexOf.call(this, element);
    });

    Set.prototype.count = Function.From(Maybe(Function)).To(Number)(function(predicate) {
      if (predicate === void 0) {
        return this.length;
      }
      return this.reduce(Array.count(predicate), 0);
    });

    Set.prototype.exists = Function.From(Function).To(Boolean)(function(predicate) {
      return 0 !== this.count(predicate);
    });

    Set.prototype.where = Function.From(Function)(function(predicate) {
      var element;
      return new this.constructor((function() {
        var i, len, results;
        results = [];
        for (i = 0, len = this.length; i < len; i++) {
          element = this[i];
          if (predicate.call(element, element)) {
            results.push(element);
          }
        }
        return results;
      }).call(this));
    });

    Set.prototype.each = Function.Chaining.From(Function)(function(fn) {
      var element, i, len, results;
      results = [];
      for (i = 0, len = this.length; i < len; i++) {
        element = this[i];
        results.push(fn.call(element, element));
      }
      return results;
    });

    Set.prototype.map = Function.From(Function)(function(fn) {
      var element;
      return new Set((function() {
        var i, len, results;
        results = [];
        for (i = 0, len = this.length; i < len; i++) {
          element = this[i];
          results.push(fn.call(element, element));
        }
        return results;
      }).call(this));
    });

    Set.prototype.mapAll = Function.From(Function)(function(fn) {
      var element;
      return new this.constructor(Array.flatten((function() {
        var i, len, results;
        results = [];
        for (i = 0, len = this.length; i < len; i++) {
          element = this[i];
          results.push(Array.prototype.slice.call(fn.call(element, element)));
        }
        return results;
      }).call(this)));
    });

    Set.prototype.reduce = Function.From(Function, Maybe(Value))(function(reduction, initial) {
      return Array.prototype.reduce.apply(this, [reduction].concat(slice.call((initial != null ? [initial] : []))));
    });

    Set.prototype.partition = Function.From(Function).Returning(function() {
      return new (Map.To(Set).Using(Set.union));
    })(function(map) {
      return function(key) {
        var element, i, len, results;
        results = [];
        for (i = 0, len = this.length; i < len; i++) {
          element = this[i];
          results.push(map.add(key.call(element, element), element));
        }
        return results;
      };
    });

    Set.subset = Predicate.From(Set, Set)(function(first, second) {
      var element;
      return Array.reduce(Boolean.and)((function() {
        var i, len, results;
        results = [];
        for (i = 0, len = first.length; i < len; i++) {
          element = first[i];
          results.push(second.member(element));
        }
        return results;
      })());
    });

    Set.equal = Predicate.From(Set, Set)(function(first, second) {
      return first.count() === second.count() && Set.subset(first, second) && Set.subset(second, first);
    });

    Set.union = Function.From([Set])(function() {
      var element, set, sets;
      sets = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return new this(Array.concat.apply(Array, (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = sets.length; i < len; i++) {
          set = sets[i];
          results.push((function() {
            var j, len1, results1;
            results1 = [];
            for (j = 0, len1 = set.length; j < len1; j++) {
              element = set[j];
              results1.push(element);
            }
            return results1;
          })());
        }
        return results;
      })()));
    });

    Set.intersection = Function.From([Set])(function() {
      var element, first, rest;
      first = arguments[0], rest = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (first == null) {
        first = [];
      }
      return new this((function() {
        var i, len, results;
        results = [];
        for (i = 0, len = first.length; i < len; i++) {
          element = first[i];
          if (rest.all(function() {
            return this.member(element);
          })) {
            results.push(element);
          }
        }
        return results;
      })());
    });

    Set.difference = Function.From(Set, Set)(function() {
      var element, first, rest;
      first = arguments[0], rest = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (first == null) {
        first = [];
      }
      return new this((function() {
        var i, len, results;
        results = [];
        for (i = 0, len = first.length; i < len; i++) {
          element = first[i];
          if (rest.none(function() {
            return this.member(element);
          })) {
            results.push(element);
          }
        }
        return results;
      })());
    });

    Set.product = Function.From([Set]).Returning(function() {
      return new this;
    })(function(product) {
      return function() {
        var sets;
        sets = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      };
    });

    Set.prototype.to = Function.From(Function)(function(constructor) {
      var element;
      return new constructor((function() {
        var i, len, results;
        results = [];
        for (i = 0, len = this.length; i < len; i++) {
          element = this[i];
          results.push(element);
        }
        return results;
      }).call(this));
    });

    Set.Of = Function.Cache.From(Function).To(Function)(function(constructor) {
      return (function(superClass) {
        extend(_Class, superClass);

        function _Class() {
          return _Class.__super__.constructor.apply(this, arguments);
        }

        _Class.prototype.add = Function.Of(constructor)(_Class.prototype.add);

        return _Class;

      })(this);
    });

    return Set;

  })();
  window.List = List = (function() {
    function List(elements) {
      var element, i, len;
      if (elements == null) {
        elements = [];
      }
      if (typeof elements === 'string' || arguments.length > 1 || (elements.length == null)) {
        elements = Array.prototype.slice.call(arguments);
      }
      for (i = 0, len = elements.length; i < len; i++) {
        element = elements[i];
        this.add(element);
      }
    }

    List.prototype.add = Function.Chaining(function(element) {
      return Array.prototype.push.call(this, element);
    });

    List.prototype.member = function(element) {
      return -1 !== Array.prototype.indexOf.call(this, element);
    };

    List.prototype.where = Function.From(Function)(function(predicate) {
      var element;
      return new this.constructor((function() {
        var i, len, results;
        results = [];
        for (i = 0, len = this.length; i < len; i++) {
          element = this[i];
          if (predicate.call(element, element)) {
            results.push(element);
          }
        }
        return results;
      }).call(this));
    });

    List.prototype.each = Function.Chaining.From(Function)(function(fn) {
      var element, i, len, results;
      results = [];
      for (i = 0, len = this.length; i < len; i++) {
        element = this[i];
        results.push(fn.call(element, element));
      }
      return results;
    });

    List.prototype.map = Function.From(Function)(function(fn) {
      var element;
      return new List((function() {
        var i, len, results;
        results = [];
        for (i = 0, len = this.length; i < len; i++) {
          element = this[i];
          results.push(fn.call(element, element));
        }
        return results;
      }).call(this));
    });

    List.prototype.mapAll = Function.From(Function)(function(fn) {
      var element;
      return new this.constructor(Array.flatten((function() {
        var i, len, results;
        results = [];
        for (i = 0, len = this.length; i < len; i++) {
          element = this[i];
          results.push(Array.prototype.slice.call(fn.call(element, element)));
        }
        return results;
      }).call(this)));
    });

    List.concat = function() {
      var lists;
      lists = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return new this(Array.concat.apply(Array, lists));
    };

    List.Of = Function.Cache.From(Function).To(Function)(function(constructor) {
      return (function(superClass) {
        extend(_Class, superClass);

        function _Class() {
          return _Class.__super__.constructor.apply(this, arguments);
        }

        _Class.prototype.add = Function.Of(constructor)(_Class.prototype.add);

        return _Class;

      })(this);
    });

    return List;

  })();
  window.Map = Map = (function() {
    function Map(mappings) {
      this._ = {};
      if (mappings instanceof Object) {
        this.add(mappings);
      }
    }

    Map.prototype.add = Function.overload([
      Function.From(Scalar, Value)(Function.Chaining(function(key, value) {
        return this._[key] = value;
      })), Function.From(Object)(Function.Chaining(function(mappings) {
        var key, results, value;
        results = [];
        for (key in mappings) {
          if (!hasProp.call(mappings, key)) continue;
          value = mappings[key];
          results.push(this.add(key, value));
        }
        return results;
      }))
    ]);

    Map.prototype.remove = Function.Chaining(function(key) {
      return delete this._[key];
    });

    Map.prototype.get = function(key) {
      return this._[key];
    };

    Map.prototype.keys = function() {
      var key;
      return new Set((function() {
        var ref, results;
        ref = this._;
        results = [];
        for (key in ref) {
          if (!hasProp.call(ref, key)) continue;
          results.push(key);
        }
        return results;
      }).call(this));
    };

    Map.prototype.each = function(fn) {
      var key, ref, results, value;
      ref = this._;
      results = [];
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        results.push(fn(key, value));
      }
      return results;
    };

    Map.prototype.ensure = Function.identity;

    Map.To = Function.Cache.From(Function).To(Function)(function(constructor) {
      return (function(superClass) {
        extend(_Class, superClass);

        function _Class() {
          return _Class.__super__.constructor.apply(this, arguments);
        }

        _Class.prototype.add = _Class.prototype.add.extend([
          Function.From(Scalar, Value)(Function.Chaining(function(key, value) {
            return this._[key] = this.ensure(value);
          })), Function.From(Array)(Function.Chaining(function(keys) {
            var i, key, len, results;
            results = [];
            for (i = 0, len = keys.length; i < len; i++) {
              key = keys[i];
              results.push(this.add(key, this.ensure()));
            }
            return results;
          }))
        ]);

        _Class.prototype.ensure = Object.ensure(constructor);

        _Class.value_constructor = constructor;

        return _Class;

      })(this);
    });

    Map.Using = Function.Cache.From(Function).To(Function)(function(combine) {
      combine = combine.bind(this.value_constructor);
      return (function(superClass) {
        extend(_Class, superClass);

        function _Class() {
          return _Class.__super__.constructor.apply(this, arguments);
        }

        _Class.prototype.add = _Class.prototype.add.extend([
          Function.From(Scalar, Value)(Function.Chaining(function(key, value) {
            return this._[key] = !this._[key] ? this.ensure(value) : combine(this.ensure(value), this._[key]);
          }))
        ]);

        return _Class;

      })(this);
    });

    return Map;

  })();
  window.Stream = Stream = (function() {
    function Stream() {
      this.fns = [];
    }

    Stream.prototype.add = Function.Chaining(function() {
      var first, fn, i, len, ref, rest, results;
      first = arguments[0], rest = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      ref = this.fns;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        fn = ref[i];
        results.push(fn.call.apply(fn, [first, first].concat(slice.call(rest))));
      }
      return results;
    });

    Stream.prototype.each = Function.From(Function)(function(fn) {
      return this.fns.push(fn);
    });

    Stream.prototype.derive = Function.From(Function).Returning(function() {
      return new this.constructor();
    })(function(child) {
      return function(fn) {
        return this.each(fn.bind(child));
      };
    });

    Stream.Of = Function.Cache.From(Function).To(Function)(function(constructor) {
      return (function(superClass) {
        extend(_Class, superClass);

        function _Class() {
          return _Class.__super__.constructor.apply(this, arguments);
        }

        _Class.prototype.add = Function.Of(constructor)(_Class.prototype.add);

        return _Class;

      })(this);
    });

    Stream.prototype.map = Function.From(Function).To(Stream)(function(fn) {
      return this.derive(function() {
        var first, rest;
        first = arguments[0], rest = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        return this.add(fn.call.apply(fn, [first, first].concat(slice.call(rest))));
      });
    });

    Stream.prototype.where = Function.From(Function).To(Stream)(function(predicate) {
      return this.derive(function() {
        var first, rest;
        first = arguments[0], rest = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        if (predicate.call.apply(predicate, [first, first].concat(slice.call(rest)))) {
          return this.add.apply(this, [first].concat(slice.call(rest)));
        }
      });
    });

    Stream.prototype.take = Function.From(Number).To(Stream)(function(number) {
      return this.where(function() {
        return number-- > 0;
      });
    });

    Stream.prototype.drop = Function.From(Number).To(Stream)(function(number) {
      return this.where(function() {
        return --number < 0;
      });
    });

    Stream.prototype.transition = Function.To(Stream)(function() {
      return (function(_this) {
        return function(last) {
          return _this.where(function(x) {
            return Boolean((!Value.equal(x, last)) && ((last = x) || true));
          });
        };
      })(this)(void 0);
    });

    Stream.prototype.control = Function.From(Stream).To(Stream)(function(control) {
      return (function(_this) {
        return function(active) {
          control.each(Function.Of(Boolean)(function(state) {
            return active = state;
          }));
          return _this.where(function() {
            return active;
          });
        };
      })(this)(true);
    });

    Stream.prototype.between = Function.From(Stream, Stream).To(Stream)(function(start, stop) {
      return this.control(Stream.disjoin(start.map(Boolean.True), stop.map(Boolean.False)));
    });

    Stream.prototype.accumulate = Function.From(Function, Maybe(Value)).To(Stream)(function(reduction, initial) {
      if (initial == null) {
        initial = reduction.unit;
      }
      return (function(_this) {
        return function(acc) {
          return _this.derive(function() {
            var args;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            return this.add(acc = reduction.call.apply(reduction, [this, acc].concat(slice.call(args))));
          });
        };
      })(this)(initial);
    });

    Stream.disjoin = Function.From([Stream]).Returning(function() {
      return new Stream;
    })(function(disjunction) {
      return function() {
        var i, len, results, stream, streams;
        streams = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        results = [];
        for (i = 0, len = streams.length; i < len; i++) {
          stream = streams[i];
          results.push(stream.each(function() {
            var args;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            return disjunction.add.apply(disjunction, args);
          }));
        }
        return results;
      };
    });

    return Stream;

  })();
  return window.Record = Record = (function() {
    function Record() {}

    Record.Of = Function.Cache.From(Object).To(Function)(function(constructors) {
      var constructor, field, fn1, record;
      record = (function(superClass) {
        var field;

        extend(_Class, superClass);

        function _Class(data) {
          var field, i, len, ref;
          if (data == null) {
            data = {};
          }
          this._ = {};
          ref = this.fields;
          for (i = 0, len = ref.length; i < len; i++) {
            field = ref[i];
            this[field](data[field]);
          }
        }

        _Class.prototype.fields = (function() {
          var results;
          results = [];
          for (field in constructors) {
            if (!hasProp.call(constructors, field)) continue;
            results.push(field);
          }
          return results;
        })();

        return _Class;

      })(this);
      fn1 = function(field, constructor) {
        return record.prototype[field] = Function.overload([
          Function.From(Not(Function))(Function.Of(constructor).Chaining(function(value) {
            return this._[field] = value;
          })), Function.From(Function)(Function.Chaining(function(fn) {
            return this[field](fn.call(this, this._[field]));
          })), Function.From()(function() {
            return this._[field];
          })
        ]);
      };
      for (field in constructors) {
        if (!hasProp.call(constructors, field)) continue;
        constructor = constructors[field];
        fn1(field, constructor);
      }
      return record;
    });

    return Record;

  })();
});

//# sourceMappingURL=sapphire2.js.map
