// Generated by CoffeeScript 1.7.1
var __slice = [].slice,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

define(['jmodel/topaz2', 'plugins/sapphire.dom'], function() {
  var delay;
  module('Array');
  test('Array.concat', function() {
    deepEqual(Array.concat(), [], 'Concatenation of zero arrays is empty array');
    deepEqual(Array.concat([1, 2, 3]), [1, 2, 3], 'Concatenation of one array is array');
    deepEqual(Array.concat([1, 2], [3, 4], [5, 6]), [1, 2, 3, 4, 5, 6], 'Concatenation works with more than two arguments');
    return deepEqual(Array.concat([1, 2], 3, 4, [5, 6]), [1, 2, 3, 4, 5, 6], 'Concatenation treats bare elements as one-element arrays');
  });
  test('Array.map', function() {
    var double;
    double = function(x) {
      return 2 * x;
    };
    deepEqual(Array.map(double)([]), [], 'Array mapping works with empty arrays');
    return deepEqual(Array.map(double)([1, 2, 3, 4, 5]), [2, 4, 6, 8, 10], 'Array mapping works with non-empty arrays');
  });
  test('Array.zip', function() {
    deepEqual(Array.zip(), [], 'Zip of zero arrays is empty array');
    deepEqual(Array.zip([1, 2]), [[1], [2]], 'Zip works with one argument');
    deepEqual(Array.zip([1, 2], [3, 4]), [[1, 3], [2, 4]], 'Zip works with two arguments');
    deepEqual(Array.zip([1, 2, 3], [4, 5, 6], [7, 8, 9]), [[1, 4, 7], [2, 5, 8], [3, 6, 9]], 'Zip works with more than two arguments');
    return deepEqual(Array.zip([1, 2], [3, 4, 5]), [[1, 3], [2, 4]], 'Only zips matching elements of arrays of unequal length');
  });
  test('Array.zipWith', function() {
    deepEqual(Array.zipWith(Math.plus)(), [], 'zipWith of zero arrays is empty array');
    deepEqual(Array.zipWith(Math.plus)([1, 2], [3, 4]), [4, 6], 'zipWith works with equal length arrays');
    return deepEqual(Array.zipWith(Math.plus)([1, 2], [3, 4, 5]), [4, 6], 'Only zips matching elements of arrays of unequal length');
  });
  test('Array.flatten', function() {
    deepEqual(Array.flatten(), [], 'Empty argument flattens to empty array');
    deepEqual(Array.flatten([1, 2, 3, 4]), [1, 2, 3, 4], 'Flat array is returned unchanged');
    deepEqual(Array.flatten([[1, 2], [3, 4], [5, 6]]), [1, 2, 3, 4, 5, 6], 'Flattens array of arrays');
    return deepEqual(Array.flatten([[1, [2, 3]], [[4, 5], 6]]), [1, 2, 3, 4, 5, 6], 'Flatten works with differing depths');
  });
  test('Array.equal', function() {
    equal(Array.equal([1, 2], [1]), false, 'Arrays with unequal lengths are not equal');
    equal(Array.equal([1, 2, 3], [1, 4, 3]), false, 'Array with unequal elements are not equal');
    equal(Array.equal([1, 2, 3], [1, 2, 3]), true, 'Arrays with equal elements are equal');
    return equal(Array.equal([1, 2, 3], ['1', '2', '3']), false, 'Equality testing is strict');
  });
  test('Array.hastypes', function() {
    equal(Array.hastypes()([]), true, 'Returns true for empty array when type array is empty');
    equal(Array.hastypes()([5]), false, 'Returns false for non-empty array when type array is empty');
    equal(Array.hastypes(Number)([5]), true, 'Returns true for single element array having correct type');
    equal(Array.hastypes(Number, String, Number)([5, 'fred', 7]), true, 'Works for longer arrays');
    equal(Array.hastypes([Number])([1, 2, 3]), true, 'Works for array type specifiers');
    return equal(Array.hastypes([Number])(), true, 'Array type specifiers include zero length case');
  });
  test('Array.all', function() {
    var odd;
    odd = function(i) {
      return i % 2 === 1;
    };
    equal(Array.all(odd)([]), true, 'Returns true for empty array (for all predicates)');
    equal(Array.all(odd)([1, 3, 5, 7]), true, 'Returns true if all elements match predicate');
    return equal(Array.all(odd)([1, 3, 4, 5, 7]), false, 'Returns false if any element does not match predicate');
  });
  test('Array::all', function() {
    var odd;
    odd = function(i) {
      return i % 2 === 1;
    };
    equal([].all(odd), true, 'Returns true for empty array (for all predicates)');
    equal([1, 3, 5, 7].all(odd), true, 'Returns true if all elements match predicate');
    return equal([1, 3, 4, 5, 7].all(odd), false, 'Returns false if any element does not match predicate');
  });
  test('Array.any', function() {
    var odd;
    odd = function(i) {
      return i % 2 === 1;
    };
    equal(Array.any(odd)([]), false, 'Returns false for empty arrays (for all predicates)');
    equal(Array.any(odd)([2, 4, 6]), false, 'Returns false if no element matches predicate');
    return equal(Array.any(odd)([2, 4, 5, 6]), true, 'Returns true if any element matches predicate');
  });
  test('Array::any', function() {
    var odd;
    odd = function(i) {
      return i % 2 === 1;
    };
    equal([].any(odd), false, 'Returns false for empty arrays (for all predicates)');
    equal([2, 4, 6].any(odd), false, 'Returns false if no element matches predicate');
    return equal([2, 4, 5, 6].any(odd), true, 'Returns true if any element matches predicate');
  });
  test('Array.none', function() {
    var odd;
    odd = function(i) {
      return i % 2 === 1;
    };
    equal(Array.none(odd)([]), true, 'Returns true for empty array (for all predicates)');
    equal(Array.none(odd)([2, 4, 6, 8]), true, 'Returns true if no elements match predicate');
    return equal(Array.none(odd)([2, 4, 5, 6, 8]), false, 'Returns false if any element matches predicate');
  });
  test('Array::none', function() {
    var odd;
    odd = function(i) {
      return i % 2 === 1;
    };
    equal([].none(odd), true, 'Returns true for empty array (for all predicates)');
    equal([2, 4, 6, 8].none(odd), true, 'Returns true if no elements match predicate');
    return equal([2, 4, 5, 6, 8].none(odd), false, 'Returns false if any element matches predicate');
  });
  test('Array.ordered', function() {
    equal(Array.ordered([1, 2, 3, 4]), true, 'Returns true if array in increasing order');
    equal(Array.ordered([2, 3, 1, 4]), false, 'Returns false if array not in increasing order');
    equal(Array.ordered(['a', 'b', 'c']), true, 'Works with ordered strings');
    return equal(Array.ordered(['b', 'a', 'c']), false, 'Works with unordered strings');
  });
  test('Array::ordered', function() {
    equal([1, 2, 3, 4].ordered(), true, 'Returns true if array in increasing order');
    equal([2, 3, 1, 4].ordered(), false, 'Returns false if array not in increasing order');
    equal(['a', 'b', 'c'].ordered(), true, 'Works with ordered strings');
    return equal(['b', 'a', 'c'].ordered(), false, 'Works with unordered strings');
  });
  test('Array.count', function() {
    var numbers, odd;
    odd = function(i) {
      return i % 2 === 1;
    };
    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
    equal(numbers.reduce(Array.count()), 9, 'Counts all elements if called without a predicate');
    equal(numbers.reduce(Array.count(odd)), 5, 'Counts elements matching predicate');
    return equal(numbers.reduce(Array.count(function() {
      return this % 2 === 1;
    })), 5, 'Can use values via context');
  });
  test('Array::count', function() {
    var numbers, odd;
    odd = function(value) {
      return value % 2 === 1;
    };
    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
    equal(numbers.count(), 9, 'Counts all elements if called without a predicate');
    equal(numbers.count(odd), 5, 'Counts elements matching predicate');
    return equal(numbers.count(function() {
      return this % 2 === 1;
    }), 5, 'Can use values via context');
  });
  test('Array.contains', function() {
    var evens, numbers, odd;
    odd = function(value) {
      return value % 2 === 1;
    };
    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
    evens = [2, 4, 6, 8];
    equal(numbers.reduce(Array.contains(), false), true, 'Returns true for non-empty array when called without predicate');
    equal(numbers.reduce(Array.contains(odd), false), true, 'Returns true if array contains element matching predicate');
    equal(evens.reduce(Array.contains(odd), false), false, 'Returns false if array does not contain element matching predicate');
    return equal(numbers.reduce(Array.contains(function() {
      return this % 2 === 1;
    })), true, 'Can use values via context');
  });
  test('Array::contains', function() {
    var evens, numbers, odd;
    odd = function(value) {
      return value % 2 === 1;
    };
    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
    evens = [2, 4, 6, 8];
    equal(numbers.contains(), true, 'Returns true for non-empty array when called without predicate');
    equal(numbers.contains(odd), true, 'Returns true if array contains element matching predicate');
    equal(evens.contains(odd), false, 'Returns false if array does not contain element matching predicate');
    return equal(numbers.contains(function() {
      return this % 2 === 1;
    }), true, 'Can use values via context');
  });
  module('Property methods');
  test('Function::extend', function() {
    var fn;
    fn = function() {
      return 'red';
    };
    equals(fn.extend({
      type: 'accessor'
    }).type, 'accessor', 'extend sets properties of function');
    return equals(fn.extend({
      type: 'accessor'
    })(), 'red', 'function runs normally after use of "extend"');
  });
  module('Basic functions');
  test('Function.identity', function() {
    var obj;
    obj = {
      name: 'test'
    };
    equals(Function.identity(obj), obj, 'Works for objects');
    return equals(Function.identity(17), 17, 'Words for bare values');
  });
  test('Function.constant', function() {
    var fred;
    fred = Function.constant('fred');
    equals(fred(), 'fred', 'Works with no arguments');
    return equals(fred(1, 2, 3), 'fred', 'Works with arguments');
  });
  test('Function.args', function() {
    return deepEqual(Function.args(1, 2, 3, 4), [1, 2, 3, 4], 'Returns arguments correctly');
  });
  test('Function.argument', function() {
    equals(Function.argument(0).call(this, 'red', 'green', 'blue'), 'red', 'Function.argument(0) works');
    equals(Function.argument(1).call(this, 'red', 'green', 'blue'), 'green', 'Function.argument(1) works');
    equals(Function.argument(2).call(this, 'red', 'green', 'blue'), 'blue', 'Function.argument(2) works');
    return equals(Function.argument(4).call(this, 'red', 'green', 'blue'), void 0, 'Function.argument(4) returns undefined if beyond bounds');
  });
  test('Function.map', function() {
    var counts;
    counts = Function.map({
      quarks: 6,
      chargedLeptons: 3,
      neutrinos: 3
    });
    equals(counts('quarks'), 6, 'Works for first mapping entry');
    return equals(counts('chargedLeptons'), 3, 'Works for other mapping entries');
  });
  test('Function.overload', function() {
    var getType;
    getType = Function.overload([
      Function.From()(function() {
        return 'nothing';
      }), Function.From(Number)(function(number) {
        return 'number';
      }), Function.From(String)(function(string) {
        return 'string';
      }), Function.From(Object)(function(object) {
        return 'object';
      })
    ]);
    equal(getType(), 'nothing', 'Correctly handles empty case');
    equal(getType(1), 'number', 'Correctly handles number argument');
    equal(getType('fred'), 'string', 'Correctly handles string argument');
    return equal(getType({
      name: 'fred'
    }), 'object', 'Correctly handles object argument');
  });
  module('Function composition');
  test('Function::then', function() {
    var blue, green, red;
    red = function(arr) {
      arr.push('red');
      return arr;
    };
    green = function(arr) {
      arr.push('green');
      return arr;
    };
    blue = function(arr) {
      arr.push('blue');
      return arr;
    };
    deepEqual(red.then(green)([]), ['red', 'green'], 'then works');
    deepEqual(red.then(green.then(blue))([]), red.then(green).then(blue)([]), 'then is associative');
    return raises((function() {
      return red.then('green');
    }), 'Raises an exception if argument is not a function');
  });
  test('Function::but', function() {
    var arr, length, red;
    arr = [];
    red = function(arr) {
      arr.push('red');
      return arr;
    };
    length = function(arr) {
      return arr.length;
    };
    equal(red.but(length)(arr), 1, 'return value of second returned');
    deepEqual(arr, ['red'], 'first function has been applied');
    return raises((function() {
      return red.but('green');
    }), 'Raises an exception if argument is not a function');
  });
  test('Function.pipe', function() {
    var addten, pipe, times2;
    times2 = function(x) {
      return 2 * x;
    };
    addten = function(x) {
      return x + 10;
    };
    equals(Function.pipe(times2, addten)(7), 24, 'piping of two functions works');
    equals(Function.pipe(addten, times2)(7), 34, 'piping works in opposite direction');
    equals(Function.pipe(times2)(7), 14, 'pipe of a single function is just that function');
    equals(Function.pipe()(7), 7, 'pipe of no functions is identity');
    raises((function() {
      return Function.pipe(times2, 7);
    }), 'Raises an exception if argument is not a function');
    pipe = Function.pipe((function() {
      return this.times(2);
    }), (function() {
      return this.plus(10);
    }));
    return equals(pipe(7), 24, 'Passes first argument or return value as context');
  });
  test('Function.compose', function() {
    var addten, composition, times2;
    times2 = function(x) {
      return 2 * x;
    };
    addten = function(x) {
      return x + 10;
    };
    equals(Function.compose(times2, addten)(7), 34, 'composition of two functions works');
    equals(Function.compose(addten, times2)(7), 24, 'composition works in opposite direction');
    equals(Function.compose(times2)(7), 14, 'composition of a single function is just that function');
    equals(Function.compose()(7), 7, 'composition of no functions is identity');
    composition = Function.compose((function() {
      return this.times(2);
    }), (function() {
      return this.plus(10);
    }));
    equals(composition(7), 34, 'Passes first argument or return value as context');
    return raises((function() {
      return Function.compose(times2, 7);
    }), 'Raises an exception if argument is not a function');
  });
  module('Aspect-like methods');
  test('Function::pre', function() {
    var a, getA, inc, red;
    a = 0;
    red = function() {
      return 'red';
    };
    inc = function() {
      return a++;
    };
    getA = function() {
      return a;
    };
    equal(red.pre(inc)(), 'red', 'pre does not interfere with function');
    equal(a, 1, 'pre function runs first');
    equal(getA.pre(inc)(), 2, 'pre function runs first');
    return raises((function() {
      return red.pre('fred');
    }), 'Raises an exception if argument is not a function');
  });
  test('post', function() {
    var add, log, logged;
    logged = '';
    log = function(c, a, b) {
      return logged = a + '+' + b + '=' + c;
    };
    add = (function(a, b) {
      return a + b;
    }).post(log);
    equal(add(2, 3), 5, 'Post-function does not affect operation of function');
    equal(logged, '2+3=5', 'Post-function is run and has access to arguments and return value');
    return raises((function() {
      return (function(a, b) {
        return a + b;
      }).post('fred');
    }), 'Raises an exception if argument is not a function');
  });
  module('Preconditions and postconditions');
  test('require', function() {
    var add2, restrictedAdd2, safeAdd2;
    add2 = function(x) {
      return x + 2;
    };
    safeAdd2 = add2.require(Function.argument(0).hastype('number'));
    restrictedAdd2 = add2.require(Function.argument(0).hastype('number')).require(Function.argument(0).between(0, 5));
    equal(safeAdd2(2), 4, 'Works as normal if requirements satisfied');
    raises((function() {
      return safeAdd2('fred');
    }), 'Throws exception if requirements not satisfied');
    equals(restrictedAdd2(2), 4, 'Works as normal if requirments satisfied');
    raises((function() {
      return restrictedAdd2('fred');
    }), 'Throws exception if first requirment unsatisfied');
    return raises((function() {
      return restrictedAdd2(6);
    }), 'Throws exception if second requirment unsatisfied');
  });
  test('ensure', function() {
    var add, faultyAdd, safeAdd, safeFaultyAdd;
    add = function(a, b) {
      return a + b;
    };
    faultyAdd = function(a, b) {
      return a + b + 1;
    };
    safeAdd = add.ensure(function(c, a, b) {
      return c === a + b;
    });
    safeFaultyAdd = faultyAdd.ensure(function(c, a, b) {
      return c === a + b;
    });
    equals(safeAdd(2, 3), 5, 'Works as expected when postcondition satisfied');
    return raises((function() {
      return safeFaultyAdd(2, 3);
    }), 'Throws exception if postcondition unsatisfied');
  });
  module('Typed functions');
  test('Function.hastypes', function() {
    equals(Function.hastypes()(), true, 'Works correctly for empty types and empty value');
    equals(Function.hastypes()(5), false, 'Works correctly for empty types and non-empty value');
    equals(Function.hastypes(Number)(5), true, 'Works correctly with single matching value');
    equals(Function.hastypes(Number)('fred'), false, 'Works correctly with single non-matching value');
    equals(Function.hastypes(String, [Number], String)('red', 1, 2, 3, 'green'), true, 'Works correctly for complex matching type');
    return equals(Function.hastypes(String, [Number], String)(1, 2, 3), false, 'Works correctly for complex non-matching type');
  });
  test('Function.Requiring', function() {
    var Person, fred;
    Person = function() {};
    Person.prototype.setAge = Function.Requiring(function(age) {
      return (18 <= age && age <= 65);
    })(function(age) {
      return this.age = age;
    });
    fred = new Person();
    fred.setAge(30);
    equals(fred.age, 30, 'Respects context');
    return raises((function() {
      return fred.setAge(70);
    }), 'Throws exception if argument violates precondition');
  });
  test('Function.From', function() {
    var Person, fred, inc, join, repeat;
    inc = Function.From(Number)(function(x) {
      return x + 1;
    });
    equals(inc(3), 4, 'works as untyped function when called with argument of correct type');
    raises((function() {
      return inc('red');
    }), 'raises an exception when called with argument of wrong type');
    repeat = Function.From(Number, String)(function(n, s) {
      var i;
      return ((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 1; 1 <= n ? _i <= n : _i >= n; i = 1 <= n ? ++_i : --_i) {
          _results.push(s);
        }
        return _results;
      })()).join('');
    });
    equals(repeat(3, 'a'), 'aaa', 'works as untyped function when called with arguments of correct type');
    raises((function() {
      return repeat('n', 'a');
    }), 'raises exception when first argument is of wrong type');
    raises((function() {
      return repeat(3, 3);
    }), 'raises exception when second argument is of wrong type');
    Person = (function() {
      var _class;

      function _Class() {
        return _class.apply(this, arguments);
      }

      _class = Function.From(String)(function(name) {
        this.name = name;
      });

      return _Class;

    })();
    fred = new Person('fred');
    equals(fred.name, 'fred', 'constructor works as untyped constructor when arguments of correct type');
    raises((function() {
      return new Person(3);
    }), 'constructor raises exception when arguments have wrong type');
    join = Function.From([String])(function() {
      var strings;
      strings = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return strings.join('');
    });
    equals(join('red', 'green', 'blue'), 'redgreenblue', 'works with repeated matching types');
    return raises((function() {
      return join(1, 2, 3);
    }), 'raises exception when repeated matching types do not match input');
  });
  test('Function.To', function() {
    var Entity, add, fred, robot;
    add = Function.To(Number)(function(a, b) {
      return a + b;
    });
    equals(add(2, 3), 5, 'works as untyped function when return value of correct type');
    raises((function() {
      return add('a', 'b');
    }), 'raises exception when return value of wrong type');
    Entity = (function() {
      function _Class(name) {
        this.name = name;
      }

      _Class.prototype.getName = Function.To(String)(function() {
        return this.name;
      });

      return _Class;

    })();
    fred = new Entity('fred');
    robot = new Entity(3);
    equals(fred.getName(), 'fred', 'works as untyped method when return value of correct type');
    return raises((function() {
      return robot.getName();
    }), 'raises exception when return value method has incorrect type');
  });
  test('Function.From.To', function() {
    var inc, inc2;
    inc = Function.From(Number).To(Number)(function(x) {
      if (x === 2) {
        return 'red';
      } else {
        return x + 1;
      }
    });
    inc2 = Function.To(Number).From(Number)(function(x) {
      if (x === 2) {
        return 'red';
      } else {
        return x + 1;
      }
    });
    equals(inc(3), 4, 'works as untyped function when called with argument of correct type and returns correct type');
    raises((function() {
      return inc('red');
    }), 'raises an exception when called with argument of wrong type');
    raises((function() {
      return inc(2);
    }), 'raises an exception when returning wrong type');
    equals(inc2(3), 4, 'works as untyped function when called with argument of correct type and returns correct type, with From and To reversed');
    raises((function() {
      return inc2('red');
    }), 'raises an exception when called with argument of wrong type, with From and To reversed');
    return raises((function() {
      return inc2(2);
    }), 'raises an exception when returning wrong type, with From and To reversed');
  });
  test('Function.Of', function() {
    var Person, fred, makePerson;
    Person = (function() {
      function _Class(name) {
        this.name = name;
      }

      _Class.prototype.setBirthday = Function.Of(Date)(function(birthday) {
        this.birthday = birthday;
      });

      return _Class;

    })();
    makePerson = Function.Of(Person)(function(person) {
      return person;
    });
    equals(makePerson('fred') instanceof Person, true, 'Implicitly applies constructor');
    equals(makePerson('fred').name, 'fred', 'Passes arguments correctly to constructor');
    fred = new Person('fred');
    fred.setBirthday('1974-11-20');
    equals(fred.birthday instanceof Date, true, 'Works correctly with methods');
    return equals(fred.birthday.toDateString(), 'Wed Nov 20 1974', 'Passes arguments correctly to method');
  });
  module('Argument manipulation');
  test('Function.Defaults', function() {
    var Person, fred, john;
    Person = Function.Defaults({
      department: 'IT'
    })(function(_arg) {
      this.name = _arg.name, this.department = _arg.department;
    });
    fred = new Person({
      name: 'Fred'
    });
    equal(fred.department, 'IT', 'Object has default values for unspecified fields');
    equal(fred.name, 'Fred', 'Other fields behave normally');
    john = new Person({
      name: 'John',
      department: 'Marketing'
    });
    return equal(john.department, 'Marketing', 'Defaults can be overriden');
  });
  test('Function.Defaults.Of', function() {
    var Person, fred, makeMarketer;
    Person = function(_arg) {
      this.name = _arg.name, this.department = _arg.department;
    };
    makeMarketer = Function.Of(Person).Defaults({
      department: 'Marketing'
    })(function(person) {
      return person;
    });
    fred = makeMarketer({
      name: 'Fred'
    });
    equal(fred instanceof Person, true, 'Makes object of correct type');
    equal(fred.department, 'Marketing', 'Object has default values for unspecified fields');
    return equal(fred.name, 'Fred', 'Other fields behave normally');
  });
  test('Function::defaults', function() {
    var Marketer, Person, fred;
    Person = function(_arg) {
      this.name = _arg.name, this.department = _arg.department;
    };
    Marketer = Person.defaults({
      department: 'Marketing'
    });
    fred = new Marketer({
      name: 'Fred'
    });
    equal(fred instanceof Person, true, 'Makes object of correct type');
    equal(fred.department, 'Marketing', 'Object has default values for unspecified fields');
    return equal(fred.name, 'Fred', 'Other fields behave normally');
  });
  module('Return value manipulation');
  test('Function.Returning', function() {
    var Person, namedPerson;
    Person = (function() {
      function _Class() {}

      return _Class;

    })();
    namedPerson = Function.Returning(function() {
      return new Person();
    })(function(person) {
      return function(name) {
        return person.name = name;
      };
    });
    equals(namedPerson('fred') instanceof Person, true, 'Returns correct value');
    return equals(namedPerson('fred').name, 'fred', 'Modified function works correctly');
  });
  test('Function.From.Returning', function() {
    var Person, deptPerson, namedPerson;
    Person = (function() {
      function _Class() {}

      return _Class;

    })();
    namedPerson = Function.From(String).Returning(function() {
      return new Person();
    })(function(person) {
      return function(name) {
        return person.name = name;
      };
    });
    equals(namedPerson('fred') instanceof Person, true, 'Returns correct value');
    equals(namedPerson('fred').name, 'fred', 'Modified function works correctly');
    raises((function() {
      return namedPerson(1);
    }), 'raises an exception if type of argument is incorrect');
    deptPerson = Function.From([String]).Returning(function() {
      return new Person();
    })(function(person) {
      return function() {
        var depts;
        depts = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return person.depts = depts.join(',');
      };
    });
    equals(deptPerson('IT', 'Marketing').depts, 'IT,Marketing', 'works correctly with repeated type specifier');
    equals(deptPerson().depts, '', 'works correct for empty arguments with repeated type specifier');
    return raises((function() {
      return deptPerson(1, 2, 3);
    }), 'raieses exception when arguments do not match repeated type specifier');
  });
  test('Function.Chaining', function() {
    var Person, fred, returned;
    Person = (function() {
      function _Class() {}

      _Class.prototype.name = Function.Chaining(function(name) {
        this.name = name;
      });

      return _Class;

    })();
    fred = new Person;
    returned = fred.name('fred');
    equal(returned, fred, 'Returns correct object');
    return equal(fred.name, 'fred', 'Function still works as expected');
  });
  test('Function::Chaining', function() {
    var Person, fred, returned;
    Person = (function() {
      function _Class() {}

      _Class.prototype.name = Function.From(String).Chaining(function(name) {
        this.name = name;
      });

      return _Class;

    })();
    fred = new Person;
    returned = fred.name('fred');
    equal(returned, fred, 'Returns correct object');
    return equal(fred.name, 'fred', 'Function still works as expected');
  });
  module('Logical functions');
  test('Function::and', function() {
    var comp, gt, lt;
    gt = function(x) {
      return x > 2;
    };
    lt = function(x) {
      return x < 6;
    };
    comp = gt.and(lt);
    equals(comp(4), true, 'true if both conditions true');
    equals(comp(1), false, 'false if first condition false');
    equals(comp(7), false, 'false if second condition false');
    return raises((function() {
      return gt.and(4);
    }), 'raises an exception if argument is not a function');
  });
  test('Function::or', function() {
    var comp, gt, lt;
    gt = function(x) {
      return x > 2;
    };
    lt = function(x) {
      return x < 2;
    };
    comp = gt.or(lt);
    equals(comp(3), true, 'true if first condition true');
    equals(comp(1), true, 'true if second condition true');
    return equals(comp(2), false, 'false if both conditions false');
  });
  test('Function::not', function() {
    var isOdd;
    isOdd = function(x) {
      return x % 2 === 1;
    };
    equals(isOdd(5), true, 'Base function works');
    equals(isOdd.not()(5), false, 'Works as expected when base returns true');
    return equals(isOdd.not()(6), true, 'Works as expected when base returns false');
  });
  test('Function.and', function() {
    equals(Function.and()(5), true, 'or of zero arguments is true');
    equals(Function.and(Function.eq(5))(5), true, 'and with one argument returns true when predicate is true');
    equals(Function.and(Function.eq(5))(7), false, 'and with one argument returns false when predicate is false');
    equals(Function.and(Function.lt(5), Function.lt(6))(3), true, 'and with two arguments returns true when both are true');
    equals(Function.and(Function.eq(5), Function.eq(6))(6), false, 'and with two arguments returns false when first is false');
    equals(Function.and(Function.eq(5), Function.eq(6))(5), false, 'or with two arguments returns false when second is false');
    return equals(Function.and(Function.eq(5), Function.eq(6))(7), false, 'or with two arguments returns false when neither is true');
  });
  test('Function.or', function() {
    equals(Function.or()(5), false, 'or of zero arguments is false');
    equals(Function.or(Function.eq(5))(5), true, 'or with one argument returns true when predicate is true');
    equals(Function.or(Function.eq(5))(7), false, 'or with one argument returns false when predicate is false');
    equals(Function.or(Function.eq(5), Function.eq(6))(5), true, 'or with two arguments returns true when first is true');
    equals(Function.or(Function.eq(5), Function.eq(6))(6), true, 'or with two arguments returns true when second is true');
    return equals(Function.or(Function.eq(5), Function.eq(6))(7), false, 'or with two arguments returns false when neither is true');
  });
  test('Function.not', function() {
    equals(Function.not(Function.eq(5))(6), true, 'not returns true when predicate returns false');
    return equals(Function.not(Function.eq(5))(5), false, 'not returns false when predicate returns true');
  });
  module('Function: Ordering');
  test('Function.asc', function() {});
  module('Predicate methods');
  test('Function.eq', function() {
    equal(Function.eq(5)(5), true, 'returns true when applied to value equal to argument');
    return equal(Function.eq(5)(3), false, 'returns false when applied to value not equal to argument');
  });
  test('Function.eq', function() {
    var sumsToFive;
    sumsToFive = Math.plus.eq(5);
    equal(sumsToFive(2, 3), true, 'Returns true when return value equals correct value');
    return equal(sumsToFive(2, 2), false, 'Returns false when return value does not equal correct value');
  });
  test('Function.neq', function() {
    equal(Function.neq(5)(3), true, 'returns true when applied to value not equal to argument');
    return equal(Function.neq(5)(5), false, 'returns false when applied to value equal to argument');
  });
  test('Function.lt', function() {
    equal(Function.lt(5)(3), true, 'returns true when applied to value less than argument');
    equal(Function.lt(5)(5), false, 'returns false when applied to value equal to argument');
    return equal(Function.lt(5)(7), false, 'returns false when applied to value greater than argument');
  });
  test('Function.gt', function() {
    equal(Function.gt(5)(3), false, 'returns false when applied to value less than argument');
    equal(Function.gt(5)(5), false, 'returns false when applied to value equal to argument');
    return equal(Function.gt(5)(7), true, 'returns true when applied to value greater than argument');
  });
  test('Function.lte', function() {
    equal(Function.lte(5)(3), true, 'returns true when applied to value less than argument');
    equal(Function.lte(5)(5), true, 'returns true when applied to value equal to argument');
    return equal(Function.lte(5)(7), false, 'returns false when applied to value greater than argument');
  });
  test('Function.gte', function() {
    equal(Function.gte(5)(3), false, 'returns false when applied to value less than argument');
    equal(Function.gte(5)(5), true, 'returns true when applied to value equal to argument');
    return equal(Function.gte(5)(7), true, 'returns true when applied to value greater than argument');
  });
  test('Function.between', function() {
    equal(Function.between(3, 5)(2), false, 'returns false when applied to value less than lower bound');
    equal(Function.between(3, 5)(3), true, 'returns true when applied to value equal to lower bound');
    equal(Function.between(3, 5)(4), true, 'returns true when applied to value strictly between bounds');
    equal(Function.between(3, 5)(5), true, 'returns true when applied to value equal to upper bound');
    equal(Function.between(3, 5)(6), false, 'returns false when applied to value greater than upper bound');
    return raises((function() {
      return Function.between(5, 3);
    }), 'throws exception when lower bound not less or equal to upper bound');
  });
  test('Function::hastype', function() {
    var test;
    test = function() {
      return 'red';
    };
    equal(test.hastype('string')(), true, 'returns true when function returns a value of specified type');
    return equal(test.hastype('number')(), false, 'returns false when function returns a value not of specified type');
  });
  test('Function::isa', function() {
    var Contact, Employee, Person;
    Contact = (function() {
      function _Class() {}

      return _Class;

    })();
    Person = (function(_super) {
      __extends(_Class, _super);

      function _Class() {
        return _Class.__super__.constructor.apply(this, arguments);
      }

      return _Class;

    })(Contact);
    Employee = (function(_super) {
      __extends(_Class, _super);

      function _Class() {
        return _Class.__super__.constructor.apply(this, arguments);
      }

      return _Class;

    })(Person);
    equal(Person.isa(Contact), true, 'Classes extend their superclass');
    equal(Employee.isa(Contact), true, 'Classes extend their supersuperclass');
    equal(Contact.isa(Person), false, 'Classes do not extend subclasses');
    return equal(Contact.isa(Contact), true, 'Classes are themselves');
  });
  module('Application methods');
  test('Function::bind', function() {
    var getName, person;
    person = {
      name: 'fred'
    };
    getName = function() {
      return this.name;
    };
    return equals(getName.bind(person)(), 'fred', 'bind works');
  });
  test('Function::curry', function() {
    var add;
    add = function(a, b) {
      return a + b;
    };
    return equals(add.curry(3)(5), 8, 'curry works');
  });
  test('Function::except', function() {
    var faulty, handled;
    faulty = function() {
      throw 'bang!';
    };
    handled = faulty.except(function(err) {
      return 'Error: ' + err;
    });
    return equal(handled(), 'Error: bang!', 'except works correctly in simplest case');
  });
  test('Function.Cache', function() {
    var add;
    add = Function.Cache(function(a, b) {
      return a + b;
    });
    equals(add(2, 3), 5, 'memoized function works normally on first call');
    return equals(add(2, 3), 5, 'memoized function works normally on subsequent calls');
  });
  test('Function::cache', function() {
    var add;
    add = (function(a, b) {
      return a + b;
    }).cache();
    equals(add(2, 3), 5, 'memoized function works normally on first call');
    return equals(add(2, 3), 5, 'memoized function works normally on subsequent calls');
  });
  module('Mapping methods');
  test('Function::map', function() {
    var mod2, oddEven;
    mod2 = function(x) {
      return x % 2;
    };
    oddEven = mod2.map({
      0: 'even',
      1: 'odd'
    });
    equal(oddEven(6), 'even', 'Works for first mapping entry');
    return equal(oddEven(7), 'odd', 'Works for second mapping entry');
  });
  module('Restricted types');
  test('Constructor.Inheriting', function() {
    var Chatty, Employee, Person;
    Person = (function() {
      function _Class() {}

      return _Class;

    })();
    Employee = (function(_super) {
      __extends(_Class, _super);

      function _Class() {
        return _Class.__super__.constructor.apply(this, arguments);
      }

      return _Class;

    })(Person);
    equal(Object.isa(Constructor.Inheriting(Person))(Employee), true, 'Returns true when argument is extension');
    equal(Object.isa(Constructor.Inheriting(String))(Employee), false, 'Returns false when argument is not extension');
    Chatty = Function.From(Constructor.Inheriting(Person))(function(constructor) {
      return (function(_super) {
        __extends(_Class, _super);

        function _Class() {
          return _Class.__super__.constructor.apply(this, arguments);
        }

        _Class.prototype.greeting = function() {
          return 'hello';
        };

        return _Class;

      })(constructor);
    });
    equal((new (Chatty(Employee))).greeting(), 'hello', 'Inheriting can be used in typed functions');
    return raises((function() {
      return new (Chatty(String));
    }), 'Restricts typed functions correctly');
  });
  module('Type');
  test('Type.union', function() {
    var Tree, green, red, tree;
    Tree = Type.union(function() {
      return {
        Empty: function() {},
        Branch: Function.From(this, this)(function(left, right) {
          this.left = left;
          this.right = right;
        }),
        Leaf: function(value) {
          this.value = value;
        }
      };
    });
    Tree.depth = Function.match([
      Type(Tree.Empty)(function() {
        return 0;
      }), Type(Tree.Leaf)(function() {
        return 1;
      }), Type(Tree.Branch)(function() {
        return 1 + Math.max(Tree.depth(this.left), Tree.depth(this.right));
      })
    ]);
    red = new Tree.Leaf('red');
    green = new Tree.Leaf('green');
    tree = new Tree.Branch(red, green);
    equals(red.value, 'red', 'Correct arguments passed to member constructor');
    equals(red instanceof Tree.Leaf, true, 'Member has correct type');
    equals(red instanceof Tree, true, 'Inheritance set up correctly');
    deepEqual([tree.left === red, tree.right === green], [true, true], 'Correct arguments passed to member constructor');
    equals(tree instanceof Tree.Branch, true, 'Member has correct type');
    equals(tree instanceof Tree, true, 'Inheritance set up correctly');
    equals(Tree.depth(red), 1, 'Works correctly for leaves');
    return equals(Tree.depth(tree), 2, 'Works correctly for branches');
  });
  module('Object');
  test('Object.extend', function() {
    var source, target;
    source = {
      forename: 'john',
      surname: 'smith'
    };
    target = {};
    Object.extend(target, source);
    equals(target.forename, 'john', 'Copies first property correctly');
    return equals(target.surname, 'smith', 'Copies second property correctly');
  });
  test('Object.construct', function() {
    var Person;
    Person = function(name, age) {
      this.name = name;
      this.age = age;
    };
    equals(Object.construct(Person)('fred', 16) instanceof Person, true, 'Creates object of correct type');
    equals(Object.construct(Person)('fred', 16).name, 'fred', 'First argument passed correctly');
    equals(Object.construct(Person)('fred', 16).age, 16, 'Second argument passed correctly');
    equals(Object.construct(Person, 'fred')(16).name, 'fred', 'Arguments can be passed in at definition time');
    equals(Object.construct(Person, 'fred')(16).age, 16, 'Arguments at call time passed in correctly when there are definition time arguments');
    equals(typeof Object.construct(String)('fred'), 'string', 'Construct handles strings correctly');
    equals(typeof Object.construct(Number)(7), 'number', 'Construct handles numbers correctly');
    equals(typeof Object.construct(Boolean)(true), 'boolean', 'Construct handles booleans correctly');
    equals(Object.construct(Boolean)(true), true, 'Construct handles boolean true correctly');
    equals(Object.construct(Boolean)(false), false, 'Construct handles boolean false correctly');
    equals(Object.construct(Date)('1997-8-29') instanceof Date, true, 'Construct creates date from string');
    equals(Object.construct(Date)('1997-8-29').getFullYear(), 1997, 'Construct creates date with correct year from string');
    equals(Object.construct(Date)('1997-8-29').getMonth(), 7, 'Construct creates date with correct month index from string');
    equals(Object.construct(Date)('1997-8-29').getDate(), 29, 'Construct creates date with correct day from string');
    equals(Object.construct(Date)('1997-8-29') instanceof Date, true, 'Construct creates date from string');
    equals(Object.construct(Date)('1997-8-29').getFullYear(), 1997, 'Construct creates date with correct year from string');
    equals(Object.construct(Date)('1997-8-29').getMonth(), 7, 'Construct creates date with correct month index from string');
    equals(Object.construct(Date)('1997-8-29').getDate(), 29, 'Construct creates date with correct day from string');
    equals(Object.construct(Date)(1997, 7, 29) instanceof Date, true, 'Construct creates date from three integers');
    equals(Object.construct(Date)(1997, 7, 29).getFullYear(), 1997, 'Construct creates date with correct year from three integers');
    equals(Object.construct(Date)(1997, 7, 29).getMonth(), 7, 'Construct creates date with correct month index from three integers');
    equals(Object.construct(Date)(1997, 7, 29).getDate(), 29, 'Construct creates date with correct day from three integers');
    equals(Object.construct(Date)(1997, 7, 29, 11, 37, 45, 231) instanceof Date, true, 'Construct creates date from seven integers');
    equals(Object.construct(Date)(1997, 7, 29, 11, 37, 45, 231).getFullYear(), 1997, 'Construct creates date with correct year from seven integers');
    equals(Object.construct(Date)(1997, 7, 29, 11, 37, 45, 231).getMonth(), 7, 'Construct creates date with correct month index from seven integers');
    equals(Object.construct(Date)(1997, 7, 29, 11, 37, 45, 231).getDate(), 29, 'Construct creates date with correct day from seven integers');
    equals(Object.construct(Date)(1997, 7, 29, 11, 37, 45, 231).getHours(), 11, 'Construct creates date with correct hours from seven integers');
    equals(Object.construct(Date)(1997, 7, 29, 11, 37, 45, 231).getMinutes(), 37, 'Construct creates date with correct minutes from seven integers');
    equals(Object.construct(Date)(1997, 7, 29, 11, 37, 45, 231).getSeconds(), 45, 'Construct creates date with correct seconds from seven integers');
    return equals(Object.construct(Date)(1997, 7, 29, 11, 37, 45, 231).getMilliseconds(), 231, 'Construct creates date with correct milliseconds from seven integers');
  });
  test('Object.ensure', function() {
    var Person, fred;
    Person = function(name, age) {
      this.name = name;
      this.age = age;
    };
    fred = new Person('fred', 30);
    equals(Object.ensure(Person)(fred), fred, 'Acts as identity when object is already of type');
    equals(Object.ensure(Person)('jane', 28) instanceof Person, true, 'Constructs new object when arguments not already of type');
    return equals(Object.ensure(Person, 'fred')(28).name, 'fred', 'Allows passing at definition time');
  });
  test('Object.keys', function() {
    var fred;
    fred = {
      forename: 'fred',
      surname: 'smith',
      age: 20,
      title: 'Mr'
    };
    return deepEqual(Object.keys(fred), ['forename', 'surname', 'age', 'title'], 'Returns keys');
  });
  test('Object.has', function() {
    var fred;
    fred = {
      forename: 'fred',
      surname: 'smith'
    };
    equal(Object.has('forename')(fred), true, 'Returns true when object has property');
    return equal(Object.has('age')(fred), false, 'Returns false when object does not have property');
  });
  test('Object.property', function() {
    var fred;
    fred = {
      forename: 'fred',
      surname: 'smith'
    };
    equals(Object.property('surname')(fred), 'smith', 'property works on properties that exist');
    equals(Object.property('age')(fred), void 0, 'property returns "undefined" for properties that do not exist');
    Object.property('surname', 'jones')(fred);
    equals(fred.surname, 'jones', 'property allows setting of values at creation time');
    raises((function() {
      return Object.property('age', 17)(fred);
    }), 'raises exception on attempting to set property that does not exist');
    return equals(fred.age, void 0, 'property is not set if it does not exist');
  });
  test('Object.method (string)', function() {
    var Adder, adder;
    Adder = (function() {
      function _Class() {}

      _Class.prototype.unit = function() {
        return 0;
      };

      _Class.prototype.add = function(a, b) {
        return a + b;
      };

      return _Class;

    })();
    adder = new Adder();
    equals(Object.method('unit')(adder), 0, 'Method works without any arguments');
    equals(Object.method('add', 2, 3)(adder), 5, 'Method works with arguments at creation time');
    equals(Object.method('add', 2)(adder, 3), 5, 'Method works with arguments at invocation time');
    return raises((function() {
      return Object.method('test')(adder);
    }), 'Method raises exception if method does not exist.');
  });
  test('Object.method (function)', function() {
    var fred, name, people;
    fred = {
      forename: 'fred',
      surname: 'smith'
    };
    name = Object.method(function() {
      return "" + this.forename + " " + this.surname;
    });
    equals(name(fred), 'fred smith', 'Method called with function sets context correctly');
    people = [
      {
        forename: 'fred',
        surname: 'smith'
      }, {
        forename: 'john',
        surname: 'jones'
      }
    ];
    deepEqual(people.map(name), ['fred smith', 'john jones'], 'Works correctly with Array::map');
    name = Object.method(function(separator) {
      return "" + this.forename + separator + this.surname;
    });
    return equals(name(fred, ' '), 'fred smith', 'Additional parameters can be passed');
  });
  test('Object.resolve', function() {
    var Person, person;
    Person = (function() {
      function Person(forename, surname, age) {
        this.forename = forename;
        this.surname = surname;
        this.age = age;
      }

      Person.prototype.name = function() {
        return "" + this.forename + " " + this.surname;
      };

      Person.prototype.Forename = function(forename) {
        this.forename = forename;
        return this;
      };

      return Person;

    })();
    person = new Person('John', 'Smith', 18);
    equals(Object.resolve('age')(person), 18, 'Resolve works with properties');
    equals(Object.resolve('name')(person), 'John Smith', 'Resolve works with methods');
    Object.resolve('age', 17)(person);
    equals(person.age, 17, 'Resolve updates properties with values given at creation time');
    Object.resolve('Forename', 'Adam')(person);
    return equals(person.forename, 'Adam', 'Resolve updates methods with values given at creation time');
  });
  test('path', function() {
    var person;
    person = {
      name: {
        first: 'John',
        last: 'Smith'
      },
      job: function() {
        return {
          company: 'Cyberdyne',
          title: 'Developer'
        };
      }
    };
    equals(Object.path('name.last')(person), 'Smith', 'path works for paths specified in a string');
    equals(Object.path('name/last', '/')(person), 'Smith', 'path works for paths specified in a string with alternative separator');
    equals(Object.path(['name', 'first'])(person), 'John', 'path works for paths specified in an array');
    equals(Object.path('job.title')(person), 'Developer', 'path works for containing methods');
    equals(Object.path(['job', 'title'])(person), 'Developer', 'path works for paths containing methods specified as arrays');
    return equals(Object.path('job.salary')(person), void 0, 'path returns undefined for paths that do not exist.');
  });
  module('Bare objects');
  test('Object.equal', function() {
    equals(Object.equal({
      name: 'fred',
      age: 20
    }, {
      name: 'fred',
      age: 20
    }), true, 'Returns true if objects have same properties and property valeus');
    equals(Object.equal({
      name: 'fred',
      age: 20
    }, {
      name: 'fred'
    }), false, 'Returns false if first object has a property that second does not have');
    equals(Object.equal({
      name: 'fred'
    }, {
      name: 'fred',
      age: 20
    }), false, 'Returns false if second object has a property that second does not have');
    return equals(Object.equal({
      name: 'fred',
      age: 20
    }, {
      name: 'fred',
      age: 25
    }), false, 'Returns false if objects have same properties but different property valeus');
  });
  test('Object.remove', function() {
    var removeProperties;
    removeProperties = Object.remove('age', 'surname');
    equals(removeProperties({
      forename: 'fred',
      surname: 'smith',
      age: 20
    }).age, void 0, 'Removes first listed property');
    equals(removeProperties({
      forename: 'fred',
      surname: 'smith',
      age: 20
    }).surname, void 0, 'Removes second listed property');
    return equals(removeProperties({
      forename: 'fred',
      surname: 'smith',
      age: 20
    }).forename, 'fred', 'Leaves other properties unchanged');
  });
  test('project', function() {
    var projectProperties;
    projectProperties = Object.project('age', 'surname');
    equals(projectProperties({
      forename: 'fred',
      surname: 'smith',
      age: 20
    }).age, 20, 'Preserves first listed property');
    equals(projectProperties({
      forename: 'fred',
      surname: 'smith',
      age: 20
    }).surname, 'smith', 'Preserves other listed properties');
    return equals(projectProperties({
      forename: 'fred',
      surname: 'smith',
      age: 20
    }).forename, void 0, 'Removes other listed properties');
  });
  test('rename', function() {
    var renameProperties;
    renameProperties = Object.rename({
      forename: 'personalName',
      surname: 'familyName'
    });
    equals(renameProperties({
      forename: 'fred',
      surname: 'smith',
      age: 20
    }).forename, void 0, 'Old name of first renamed property unavailable');
    equals(renameProperties({
      forename: 'fred',
      surname: 'smith',
      age: 20
    }).surname, void 0, 'Old name of second renamed property unavailable');
    equals(renameProperties({
      forename: 'fred',
      surname: 'smith',
      age: 20
    }).personalName, 'fred', 'New name of first renamed property available');
    equals(renameProperties({
      forename: 'fred',
      surname: 'smith',
      age: 20
    }).familyName, 'smith', 'New name of second renamed property available');
    return equals(renameProperties({
      forename: 'fred',
      surname: 'smith',
      age: 20
    }).age, 20, 'Other properties preserved');
  });
  test('union', function() {
    var a, b, c, d;
    a = {
      forename: 'fred',
      surname: 'smith'
    };
    b = {
      surname: 'jones',
      age: 20
    };
    c = {
      department: 'IT'
    };
    d = Object.union(a, b, c);
    equals(d.forename, 'fred', 'Union has property possed only by first object');
    equals(d.age, 20, 'Union has property possed only by second object');
    equals(d.department, 'IT', 'Union has property possed only by third object');
    notEqual(d.surname, void 0, 'Union has shared property');
    equals(d.surname, 'jones', 'Later objects supercede earlier ones for shared property values');
    deepEqual(Object.union(a), a, 'Union of single object is a copy of that object');
    return deepEqual(Object.union(), {}, 'Union of no objects is undefined');
  });
  test('intersection', function() {
    var a, b, c, d;
    a = {
      forename: 'fred',
      surname: 'smith',
      age: 20,
      title: 'Mr'
    };
    b = {
      forename: 'fred',
      surname: 'jones',
      age: 20,
      status: 'Employee'
    };
    c = {
      forename: 'fred',
      surname: 'jones',
      department: 'IT'
    };
    d = Object.intersection(a, b, c);
    equal(d.age, void 0, 'Properties not shared by all objects are undefined');
    equal(d.department, void 0, 'Properties not shared by all objects are undefined');
    notEqual(d.forename, void 0, 'Properties shared by all objects exist in intersection');
    notEqual(d.surname, void 0, 'Properties shared by all objects exist in intersection');
    equal(d.forename, 'fred', 'Property has same value in intersection if all objects have same value');
    equal(d.surname, 'smith', 'Earlier objects supercede earlier ones for shared property values');
    deepEqual(Object.intersection(a), a, 'Intersection of single object is a copy of that object');
    return deepEqual(Object.intersection(), {}, 'Intersection of no objects is undefined');
  });
  test('difference', function() {
    var a, b, c;
    a = {
      forename: 'john',
      surname: 'smith',
      age: 20,
      title: 'Mr'
    };
    b = {
      forename: 'fred',
      surname: 'jones',
      department: 'IT'
    };
    c = Object.difference(a, b);
    equal(c.age, 20, 'Properties not defined in second object are preserved');
    return equal(c.forename, void 0, 'Properties defined in second object are removed');
  });
  test('join', function() {
    var a, b, c, d, e, onid;
    onid = function(a, b) {
      return a.id === b.id;
    };
    a = {
      id: 1,
      name: 'fred',
      age: 20
    };
    b = {
      id: 1,
      department: 'IT'
    };
    c = {
      id: 2,
      department: 'Finance'
    };
    d = Object.join(onid)(a, b);
    e = Object.join(onid)(a, c);
    equal(e, void 0, 'Join is undefined if pair of objects does not match predicate');
    return deepEqual(d, Object.union(a, b), 'Join is union if objects match predicate');
  });
  test('Object.WithDefaults', function() {
    var Person, fred, john;
    Person = Object.WithDefaults({
      department: 'IT'
    });
    fred = Person({
      name: 'Fred'
    });
    equal(fred.department, 'IT', 'Object has default values for unspecified fields');
    equal(fred.name, 'Fred', 'Other fields behave normally');
    john = Person({
      name: 'John',
      department: 'Marketing'
    });
    return equal(john.department, 'Marketing', 'Defaults can be overriden');
  });
  module('Number');
  test('Number::equals', function() {
    var num;
    num = 3;
    equals(num.equals(2), false, 'Returns false if argument is not equal to number');
    equals(num.equals(3), true, 'Returns true if argument is equal to number');
    return raises((function() {
      return num.equals('red');
    }), 'Throws an exception when called with a non-number');
  });
  test('Number::plus', function() {
    var num;
    num = 3;
    equals(num.plus(2), 5, 'Returns sum of argument and number');
    return raises((function() {
      return num.plus('red');
    }), 'Throws an exception when called with a non-number');
  });
  test('Number::minus', function() {
    var num;
    num = 3;
    equals(num.minus(2), 1, 'Returns difference of argument and number');
    return raises((function() {
      return num.minus('red');
    }), 'Throws an exception when called with a non-number');
  });
  test('Number::times', function() {
    var num;
    num = 3;
    equals(num.times(2), 6, 'Returns product of argument and number');
    return raises((function() {
      return num.times('red');
    }), 'Throws an exception when called with a non-number');
  });
  test('Number::div', function() {
    var num;
    num = 3;
    equals(num.div(2), 1.5, 'Returns quotient of argument and number');
    return raises((function() {
      return num.div('red');
    }), 'Throws an exception when called with a non-number');
  });
  test('Number::mod', function() {
    var num;
    num = 3;
    equals(num.mod(2), 1, 'Returns number modulo argument');
    return raises((function() {
      return num.mod('red');
    }), 'Throws an exception when called with a non-number');
  });
  test('Integer', function() {
    equals(Number.Integer(5), 5, 'Returns the integer value when called on an integer.');
    return raises((function() {
      return Number.Integer(5.5);
    }), 'Throws an exception when called on a non-integer');
  });
  module('Boolean');
  module('Math');
  test('Math.plus', function() {
    equals(Math.plus(), 0, 'Returns zero for no arguments');
    equals(Math.plus(3), 3, 'Returns argument for one argument');
    return equals(Math.plus(3, 2), 5, 'Returns sum of arguments for two arguments');
  });
  test('Math.sum', function() {
    equals(Math.sum(), 0, 'Returns zero for no arguments');
    equals(Math.sum(3), 3, 'Returns argument for one argument');
    equals(Math.sum(3, 2), 5, 'Returns sum of arguments for two arguments');
    return equals(Math.sum(3, 5, 2, 4), 14, 'Sums list of more than two numbers');
  });
  test('Math.times', function() {
    equals(Math.times(), 1, 'Returns one for no arguments');
    equals(Math.times(3), 3, 'Returns argument for one argument');
    return equals(Math.times(3, 2), 6, 'Returns product of arguments for two arguments');
  });
  test('Math.product', function() {
    equals(Math.product(), 1, 'Returns one for no arguments');
    equals(Math.product(3), 3, 'Returns argument for one argument');
    equals(Math.product(3, 2), 6, 'Returns product of arguments for two arguments');
    return equals(Math.product(3, 5, 2, 4), 120, 'Returns product of list of more than two numbers');
  });
  module('Nullable');
  test('Nullable Number', function() {
    equals((Nullable(Number))(null), null, 'Returns null when called on null.');
    return equals((Nullable(Number))(5), 5, 'Throws an exception when called on a non-integer');
  });
  module('Maybe');
  test('Maybe Number', function() {
    var type, type2;
    type = Maybe(Number);
    equals(type(), void 0, 'Returns undefined when called with no arguments.');
    equals(type(void 0), void 0, 'Returns undefined when called with undefined');
    equals(type(5), 5, 'Returns value when called with value of correct type');
    equals(type.valid(void 0), true, 'Undefined is a valid value');
    equals(type.valid(5), true, 'Values from base type are valid');
    equals(type.valid('red'), false, 'Values not from base type are not valid');
    type2 = Maybe(Number);
    return equals(type, type2, 'Maybe cached correctly');
  });
  module('Promise');
  test('Promise.then', function() {
    var promise;
    promise = new Promise();
    return equals(promise.then(function() {}) instanceof Promise, true, 'Returns a Promise');
  });
  asyncTest('onFulfilled', 2, function() {
    var promise;
    promise = new Promise();
    promise.then(function(x, y) {
      equals(x, 'fred', 'onFulfilled called with fulfilment value');
      equals(y, 'smith', 'onFulfilled allows multi-part fulfilment values');
      return start();
    });
    return promise.fulfil('fred', 'smith');
  });
  asyncTest('onRejected', 1, function() {
    var promise;
    promise = new Promise();
    promise.then(void 0, function(x) {
      equals(x, 'fred', 'onRejected called with rejection reason');
      return start();
    });
    return promise.reject('fred');
  });
  test('Promise.fulfil', function() {
    var promise;
    promise = new Promise();
    promise.fulfil('fred');
    raises((function() {
      return promise.fulfil();
    }), 'Throws exception if fulfiled more than once');
    raises((function() {
      return promise.reject();
    }), 'Throws exception if rejected after fulfilled');
    equals(promise.value, 'fred', 'After fulfilment, promise value is fulfilment value');
    return equals(promise.reason, void 0, 'After fulfulment, promise reason is undefined');
  });
  test('Promise.reject', function() {
    var promise;
    promise = new Promise();
    promise.reject('fred');
    raises((function() {
      return promise.reject();
    }), 'Throws exception if rejected more than once');
    raises((function() {
      return promise.fulfil();
    }), 'Throws exception if fulfilled after rejected');
    equals(promise.value, void 0, 'After rejection, promise value is undefined');
    return equals(promise.reason, 'fred', 'After rejection, promise reason is rejection reason');
  });
  asyncTest('Promise.Fulfilled', 2, function() {
    var promise;
    promise = Promise.Fulfilled('red');
    return promise.then(function(value) {
      equals(promise instanceof Promise, true, 'Already fulfilled promises are promises');
      equals(value, 'red', 'Promise fulfilled with correct value');
      return start();
    });
  });
  asyncTest('Promise.Rejected', 2, function() {
    var promise;
    promise = Promise.Rejected('red');
    return promise.then((function() {}), function(value) {
      equals(promise instanceof Promise, true, 'Already rejected promises are promises');
      equals(value, 'red', 'Promise rejected with correct value');
      return start();
    });
  });
  asyncTest('Promise.Of', 2, function() {
    var promise;
    promise = new (Promise.Of(Date));
    promise.then(function(value) {
      equals(value instanceof Date, true, 'Creates object of correct type');
      equals(value.toDateString(), 'Wed Nov 20 1974', 'Passes arguments correctly');
      return start();
    });
    return promise.fulfil('1974-11-20');
  });
  asyncTest('Promise.Of.Fulfilled', 2, function() {
    var promise;
    promise = Promise.Of(Date).Fulfilled('1974-11-20');
    return promise.then(function(value) {
      equals(value instanceof Date, true, 'Creates object of correct type');
      equals(value.toDateString(), 'Wed Nov 20 1974', 'Passes arguments correctly');
      return start();
    });
  });
  asyncTest('Promise.Of.Rejected', 1, function() {
    var promise;
    promise = Promise.Of(Date).Rejected('error');
    return promise.then((function() {}), function(value) {
      equals(value, 'error', 'Passes argument correctly');
      return start();
    });
  });
  asyncTest('Promise.disjoin', 2, function() {
    var delay, output, promise, promise1, promise2, promise3;
    delay = function(fn) {
      return setTimeout(fn, 100);
    };
    promise1 = new Promise;
    promise2 = new Promise;
    promise3 = new Promise;
    promise = Promise.disjoin(promise1, promise2, promise3);
    equals(promise instanceof Promise, true, 'A disjunction of promises is a promise');
    output = [];
    promise.then(function(value) {
      return output.push(value);
    });
    promise2.fulfil('green');
    promise1.fulfil('red');
    return delay(function() {
      deepEqual(output, ['green'], 'Disjunction fulfilled with first fulfilled value only');
      return start();
    });
  });
  asyncTest('Promise.Of.disjoin', 3, function() {
    var delay, output, promise, promise1, promise2, promise3;
    delay = function(fn) {
      return setTimeout(fn, 100);
    };
    promise1 = new Promise;
    promise2 = new Promise;
    promise3 = new Promise;
    promise = Promise.Of(Date).disjoin(promise1, promise2, promise3);
    equals(promise instanceof Promise, true, 'A typed disjunction of promises is a promise');
    output = [];
    promise.then(function(value) {
      return output.push(value);
    });
    promise2.fulfil('1974-11-20');
    promise1.fulfil('1979-1-14');
    return delay(function() {
      var date;
      equal(output[0] instanceof Date, true, 'Constructor correctly applied');
      deepEqual((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = output.length; _i < _len; _i++) {
          date = output[_i];
          _results.push(date.toDateString());
        }
        return _results;
      })(), ['Wed Nov 20 1974'], 'Disjunction fulfilled with first fulfilled value only');
      return start();
    });
  });
  module('Tuple');
  test('Tuple.Of', function() {
    var Person, Person2, forename, fred, fred2, id, john, surname;
    Person = Tuple.Of(Number, String, String);
    fred = new Person(1, 'fred', 'smith');
    id = fred[0], forename = fred[1], surname = fred[2];
    deepEqual([id, forename, surname], [1, 'fred', 'smith'], 'Sets elements correctly');
    fred2 = new Person(1, 'fred', 'smith');
    john = new Person(2, 'john', 'smith');
    equal(Tuple.equal(fred, john), false, 'Tuples with different values are not equal');
    equal(Tuple.equal(fred, fred2), true, 'Tuples with same values are equal');
    Person2 = Tuple.Of(Number, String, String);
    return equal(Person, Person2, 'Tuple.Of cached correctly');
  });
  module('Set');
  test('Set constructor', function() {
    var colour, colours, number, numbers;
    colours = new Set(['red', 'green', 'blue']);
    equals(colours.length, 3, 'Set returns a set with correct cardinality');
    deepEqual((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = colours.length; _i < _len; _i++) {
        colour = colours[_i];
        _results.push(colour);
      }
      return _results;
    })(), ['red', 'green', 'blue'], 'Set contains correct elements');
    numbers = new Set(1, 2, 3);
    return deepEqual((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = numbers.length; _i < _len; _i++) {
        number = numbers[_i];
        _results.push(number);
      }
      return _results;
    })(), [1, 2, 3], 'Constructor can be called on bare values');
  });
  test('Set::add', function() {
    var colour, colours;
    colours = new Set(['red', 'green', 'blue']);
    colours.add('cyan').add('magenta').add('yellow');
    deepEqual((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = colours.length; _i < _len; _i++) {
        colour = colours[_i];
        _results.push(colour);
      }
      return _results;
    })(), ['red', 'green', 'blue', 'cyan', 'magenta', 'yellow'], 'Adds elements and can be chained');
    colours.add('cyan').add('magenta').add('yellow');
    return deepEqual((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = colours.length; _i < _len; _i++) {
        colour = colours[_i];
        _results.push(colour);
      }
      return _results;
    })(), ['red', 'green', 'blue', 'cyan', 'magenta', 'yellow'], 'Does not add elements more than once');
  });
  test('Set::remove', function() {
    var even, number, numbers, removed;
    numbers = new Set([1, 2, 3, 4, 5, 6, 7, 8]);
    even = function(x) {
      return x % 2 === 0;
    };
    removed = numbers.remove(even);
    deepEqual(((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = numbers.length; _i < _len; _i++) {
        number = numbers[_i];
        _results.push(number);
      }
      return _results;
    })()).sort(), [1, 3, 5, 7], 'Leaves correct elements in set');
    deepEqual(((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = removed.length; _i < _len; _i++) {
        number = removed[_i];
        _results.push(number);
      }
      return _results;
    })()).sort(), [2, 4, 6, 8], 'Removes correct elements');
    equals(numbers.length, 4, 'Set has correct cardinality after removal');
    equals(removed instanceof Set, true, 'Removed elements returned as Set');
    removed = numbers.remove();
    equals(numbers.length, 0, 'Set has correct cardinality after removal');
    return deepEqual((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = numbers.length; _i < _len; _i++) {
        number = numbers[_i];
        _results.push(number);
      }
      return _results;
    })(), [], 'Removes all elements when called without an argument');
  });
  test('Set::member', function() {
    var colours;
    colours = new Set(['red', 'green', 'blue']);
    equals(colours.member('red'), true, 'Returns true if test element is a member');
    equals(colours.member('cyan'), false, 'Returns false if test element is not a member');
    return equals(colours.member(), false, 'Returns false if called without an argument');
  });
  test('Set::count', function() {
    var empty, numbers;
    numbers = new Set([1, 2, 3, 4, 5, 6, 7, 8]);
    empty = new Set([]);
    equals(numbers.count(), 8, 'Returns cardinality of set when called without a predicate');
    equals(numbers.count(function() {
      return 0 === this.mod(2);
    }), 4, 'Returns number of elements matching predicate when called with predicate');
    return equals(empty.count(), 0, 'Empty set is empty');
  });
  test('Set::where', function() {
    var evens, number, numbers;
    numbers = new Set([1, 2, 3, 4, 5, 6, 7, 8]);
    evens = numbers.where(function() {
      return 0 === this.mod(2);
    });
    deepEqual((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = evens.length; _i < _len; _i++) {
        number = evens[_i];
        _results.push(number);
      }
      return _results;
    })(), [2, 4, 6, 8], 'Filters according to criteria');
    deepEqual((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = numbers.length; _i < _len; _i++) {
        number = numbers[_i];
        _results.push(number);
      }
      return _results;
    })(), [1, 2, 3, 4, 5, 6, 7, 8], 'Leaves original set unchanged');
    equals(evens instanceof Set, true, 'Returns a Set');
    return raises((function() {
      return numbers.where('red');
    }), 'Raises an exception if argument is not a function');
  });
  test('Set::each', function() {
    var numbers, output;
    numbers = new Set([1, 2, 3, 4, 5, 6, 7, 8]);
    output = [];
    numbers.each(function() {
      return output.push(this);
    });
    return deepEqual(output, [1, 2, 3, 4, 5, 6, 7, 8], 'Function is called for each element of set');
  });
  test('Set::reduce', function() {
    var empty, numbers;
    numbers = new Set([1, 2, 3, 4, 5, 6, 7, 8]);
    empty = new Set([]);
    equal(numbers.reduce(Math.plus), 36, 'Reduces values correctly');
    equal(numbers.reduce(Math.plus, 0), 36, 'Allows initial value');
    return equal(empty.reduce(Math.plus, 0), 0, 'Works with empty set and initial value');
  });
  test('Set::partition', function() {
    var number, numbers, partition;
    numbers = new Set([1, 2, 3, 4, 5, 6, 7, 8]);
    partition = numbers.partition((function() {
      return 0 === this.mod(2);
    }).map({
      "true": 'even',
      "false": 'odd'
    }));
    deepEqual(((function() {
      var _i, _len, _ref, _results;
      _ref = partition.get('even');
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        number = _ref[_i];
        _results.push(number);
      }
      return _results;
    })()).sort(), [2, 4, 6, 8], 'Produces correct value for key');
    equals(partition instanceof Map, true, 'Returns a Map');
    return raises((function() {
      return numbers.partition('red');
    }), 'Raises an exception if argument not a function');
  });
  test('Set.subset', function() {
    var empty, numbers, odds;
    numbers = new Set([1, 2, 3, 4, 5, 6, 7, 8]);
    odds = new Set([1, 3, 5, 7]);
    empty = new Set([]);
    equals(Set.subset(numbers, numbers), true, 'A set is a subset of itself');
    equals(Set.subset(empty, numbers), true, 'The empty set is a subset of all sets');
    equals(Set.subset(odds, numbers), true, 'Returns true when first is subset of second');
    equals(Set.subset(numbers, odds), false, 'Returns false when first is not subset of second');
    raises((function() {
      return Set.subset(1, numbers);
    }), 'Raises an exception if first argument not a Set');
    return raises((function() {
      return Set.subset(odds, 1);
    }), 'Raises an exception if second argument not a Set');
  });
  test('Set.equal', function() {
    var evens, more_odds, numbers, odds;
    numbers = new Set([7, 5, 3, 1]);
    odds = new Set([1, 3, 5, 7]);
    evens = new Set([2, 4, 6, 8]);
    more_odds = new Set([1, 3, 5, 7, 9]);
    equals(Set.equal(numbers, numbers), true, 'A set is equal to itself');
    equals(Set.equal(numbers, odds), true, 'Two sets with the same elements are equal');
    equals(Set.equal(odds, evens), false, 'Two sets with the same cardinality but different elements are not equal');
    equals(Set.equal(odds, more_odds), false, 'Two sets with different numbers of elements are not equal');
    raises((function() {
      return Set.equal(1, numbers);
    }), 'Raises an exception if first argument not a Set');
    return raises((function() {
      return Set.equal(numbers, 1);
    }), 'Raises an exception if second argument not a Set');
  });
  test('Set.union', function() {
    var evens, number, odds, union, zero;
    odds = new Set([1, 3, 5, 7]);
    evens = new Set([2, 4, 6, 8]);
    zero = new Set([0]);
    union = Set.union(odds, evens, zero);
    deepEqual(((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = union.length; _i < _len; _i++) {
        number = union[_i];
        _results.push(number);
      }
      return _results;
    })()).sort(), [0, 1, 2, 3, 4, 5, 6, 7, 8], 'Union contains correct elements');
    deepEqual((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = odds.length; _i < _len; _i++) {
        number = odds[_i];
        _results.push(number);
      }
      return _results;
    })(), [1, 3, 5, 7], 'Leaves first set unchanged');
    deepEqual((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = evens.length; _i < _len; _i++) {
        number = evens[_i];
        _results.push(number);
      }
      return _results;
    })(), [2, 4, 6, 8], 'Leaves other sets unchanged');
    deepEqual((function() {
      var _i, _len, _ref, _results;
      _ref = Set.union(odds);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        number = _ref[_i];
        _results.push(number);
      }
      return _results;
    })(), [1, 3, 5, 7], 'Union works with single argument');
    deepEqual((function() {
      var _i, _len, _ref, _results;
      _ref = Set.union();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        number = _ref[_i];
        _results.push(number);
      }
      return _results;
    })(), [], 'Union works with zero arguments');
    equals(union instanceof Set, true, 'Returns a Set');
    raises((function() {
      return Set.union(1, evens);
    }), 'Raises an exception if first argument not a Set');
    return raises((function() {
      return Set.union(odds, 1);
    }), 'Raises an exception if second argument not a Set');
  });
  test('Set.intersection', function() {
    var evens, intersection, number, numbers, positives;
    numbers = new Set([-8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8]);
    evens = new Set([-8, -6, -4, -2, 0, 2, 4, 6, 8]);
    positives = new Set([1, 2, 3, 4, 5, 6, 7, 8]);
    intersection = Set.intersection(numbers, evens, positives);
    deepEqual(((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = intersection.length; _i < _len; _i++) {
        number = intersection[_i];
        _results.push(number);
      }
      return _results;
    })()).sort(), [2, 4, 6, 8], 'Intersection contains correct elements');
    deepEqual((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = numbers.length; _i < _len; _i++) {
        number = numbers[_i];
        _results.push(number);
      }
      return _results;
    })(), [-8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8], 'Leaves first set unchanged');
    deepEqual((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = evens.length; _i < _len; _i++) {
        number = evens[_i];
        _results.push(number);
      }
      return _results;
    })(), [-8, -6, -4, -2, 0, 2, 4, 6, 8], 'Leaves other sets unchanged');
    deepEqual((function() {
      var _i, _len, _ref, _results;
      _ref = Set.intersection(positives);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        number = _ref[_i];
        _results.push(number);
      }
      return _results;
    })(), [1, 2, 3, 4, 5, 6, 7, 8], 'Intersection works with single argument');
    deepEqual((function() {
      var _i, _len, _ref, _results;
      _ref = Set.intersection();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        number = _ref[_i];
        _results.push(number);
      }
      return _results;
    })(), [], 'Intersection works with zero arguments');
    equals(intersection instanceof Set, true, 'Returns a Set');
    raises((function() {
      return Set.intersection(1, evens);
    }), 'Raises an exception if first argument not a Set');
    return raises((function() {
      return Set.intersection(numbers, 1);
    }), 'Raises an exception if second argument not a Set');
  });
  test('Set.difference', function() {
    var difference, number, numbers, odds;
    numbers = new Set([1, 2, 3, 4, 5, 6, 7, 8]);
    odds = new Set([1, 3, 5, 7]);
    difference = Set.difference(numbers, odds);
    deepEqual(((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = difference.length; _i < _len; _i++) {
        number = difference[_i];
        _results.push(number);
      }
      return _results;
    })()).sort(), [2, 4, 6, 8], 'Difference contains correct elements');
    deepEqual((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = numbers.length; _i < _len; _i++) {
        number = numbers[_i];
        _results.push(number);
      }
      return _results;
    })(), [1, 2, 3, 4, 5, 6, 7, 8], 'Leaves first set unchanged');
    deepEqual((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = odds.length; _i < _len; _i++) {
        number = odds[_i];
        _results.push(number);
      }
      return _results;
    })(), [1, 3, 5, 7], 'Leaves second set unchanged');
    equals(difference instanceof Set, true, 'Returns a Set');
    raises((function() {
      return Set.difference(1, odds);
    }), 'Raises an exception if first argument not a Set');
    return raises((function() {
      return Set.difference(numbers, 1);
    }), 'Raises an exception if second argument not a Set');
  });
  test('Set::to', function() {
    var even, list, number, numbers;
    numbers = new Set([1, 2, 3, 4, 5, 6, 7, 8]);
    even = even = function(x) {
      return x % 2 === 0;
    };
    list = numbers.to(List);
    equals(list instanceof List, true, 'Casts to correct type');
    deepEqual((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        number = list[_i];
        _results.push(number);
      }
      return _results;
    })(), [1, 2, 3, 4, 5, 6, 7, 8], 'Constructor is passed correct elements');
    return raises((function() {
      return numbers.to('red');
    }), 'Raises an exception if not called with a function');
  });
  test('Set.Of', function() {
    var DateSet1, DateSet2, date, dates;
    dates = new (Set.Of(Date));
    dates.add('1974-11-20').add('1979-1-14');
    deepEqual((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = dates.length; _i < _len; _i++) {
        date = dates[_i];
        _results.push(date instanceof Date);
      }
      return _results;
    })(), [true, true], 'Implicitly applies constructor');
    deepEqual((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = dates.length; _i < _len; _i++) {
        date = dates[_i];
        _results.push(date.toDateString());
      }
      return _results;
    })(), ['Wed Nov 20 1974', 'Sun Jan 14 1979'], 'Passes correct values to constructor');
    DateSet1 = Set.Of(Date);
    DateSet2 = Set.Of(Date);
    return equals(DateSet1, DateSet2, 'Typed Set constructor cached correctly');
  });
  module('List');
  test('List::where', function() {
    var number, numbers, odds;
    numbers = new List([1, 2, 3, 4, 5, 6, 7, 8, 9]);
    odds = numbers.where(function() {
      return 1 === this.mod(2);
    });
    deepEqual((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = odds.length; _i < _len; _i++) {
        number = odds[_i];
        _results.push(number);
      }
      return _results;
    })(), [1, 3, 5, 7, 9], 'Filtered list contains correct elements');
    deepEqual((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = numbers.length; _i < _len; _i++) {
        number = numbers[_i];
        _results.push(number);
      }
      return _results;
    })(), [1, 2, 3, 4, 5, 6, 7, 8, 9], 'Leaves original set unchanged');
    equals(odds instanceof List, true, 'Returns a List');
    return raises((function() {
      return numbers.map('red');
    }), 'Raises an exception if argument is not a function');
  });
  test('List::map', function() {
    var number, numbers, squares;
    numbers = new List([1, 2, 3, 4, 5, 6, 7, 8, 9]);
    squares = numbers.map(function() {
      return this * this;
    });
    deepEqual((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = squares.length; _i < _len; _i++) {
        number = squares[_i];
        _results.push(number);
      }
      return _results;
    })(), [1, 4, 9, 16, 25, 36, 49, 64, 81], 'Mapped set contains correct elements');
    deepEqual((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = numbers.length; _i < _len; _i++) {
        number = numbers[_i];
        _results.push(number);
      }
      return _results;
    })(), [1, 2, 3, 4, 5, 6, 7, 8, 9], 'Leaves original set unchanged');
    equals(squares instanceof List, true, 'Returns a List');
    return raises((function() {
      return numbers.map('red');
    }), 'Raises an exception if argument is not a function');
  });
  test('List.concat', function() {
    var first, number, numbers, second, third, x;
    first = [1, 2, 3];
    second = [4, 5, 6];
    third = [7, 8, 9];
    numbers = List.concat(first, second, third);
    deepEqual((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = numbers.length; _i < _len; _i++) {
        number = numbers[_i];
        _results.push(number);
      }
      return _results;
    })(), [1, 2, 3, 4, 5, 6, 7, 8, 9], 'Concatenates correctly');
    equals(numbers instanceof List, true, 'Returns correct type');
    return deepEqual((function() {
      var _i, _len, _ref, _results;
      _ref = List.concat();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        x = _ref[_i];
        _results.push(x);
      }
      return _results;
    })(), [], 'Correctly handles zero arguments');
  });
  module('Map');
  test('Map constructor', function() {
    var empty, falls, key;
    falls = new Map({
      rome: 476,
      constantinople: 1453
    });
    deepEqual((function() {
      var _ref, _results;
      _ref = falls._;
      _results = [];
      for (key in _ref) {
        if (!__hasProp.call(_ref, key)) continue;
        _results.push(key);
      }
      return _results;
    })(), ['rome', 'constantinople'], 'Map has correct keys');
    deepEqual([falls._['rome'], falls._['constantinople']], [476, 1453], 'Keys map to correct values');
    empty = new Map();
    return equals(empty instanceof Map, true, 'Empty maps are valid');
  });
  test('Map::remove', function() {
    var falls, key;
    falls = new Map({
      rome: 476,
      constantinople: 1453
    });
    falls.remove('rome');
    deepEqual((function() {
      var _ref, _results;
      _ref = falls._;
      _results = [];
      for (key in _ref) {
        if (!__hasProp.call(_ref, key)) continue;
        _results.push(key);
      }
      return _results;
    })(), ['constantinople'], 'Correctly removes key');
    return equals(falls.get('constantinople'), 1453, 'Remaining key mappings unchanged');
  });
  test('Map::keys', function() {
    var cities, city, falls;
    falls = new Map({
      rome: 476,
      constantinople: 1453
    });
    cities = falls.keys();
    equals(cities instanceof Set, true, 'Returns a Set');
    return deepEqual(((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = cities.length; _i < _len; _i++) {
        city = cities[_i];
        _results.push(city);
      }
      return _results;
    })()).sort(), ['constantinople', 'rome'], 'Returns correct keys');
  });
  test('Map.To', function() {
    var DateMap1, DateMap2, falls;
    falls = new (Map.To(Date))({
      rome: '476-9-4',
      constantinople: '1453-5-29'
    });
    equals(falls.get('rome') instanceof Date, true, 'Converts values to correct type');
    equals(falls.get('rome').toDateString(), 'Fri Sep 04 476', 'Mapped values are correct');
    DateMap1 = Map.To(Date);
    DateMap2 = Map.To(Date);
    equals(DateMap1, DateMap2, 'Typed Map constructor cached correctly');
    return equals(Map.To(Date), Map.To(Date), 'Map.To cached correctly');
  });
  test('Map.Using', function() {
    var departments, person, scores;
    scores = new (Map.Using(Math.plus))({
      england: 0,
      france: 0
    });
    scores.add('england', 3);
    scores.add('france', 2);
    scores.add('england', 5);
    scores.add('france', 3);
    deepEqual([scores.get('england'), scores.get('france')], [8, 5], 'Combines values correctly');
    departments = new (Map.To(Set).Using(Set.union));
    departments.add('IT', 'Richard');
    departments.add('Finance', 'Michael');
    departments.add('IT', 'Jonathan');
    departments.add('Finance', 'Rachel');
    equals(departments.get('IT') instanceof Set, true, 'Converts values to correct type');
    deepEqual(((function() {
      var _i, _len, _ref, _results;
      _ref = departments.get('IT');
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        person = _ref[_i];
        _results.push(person);
      }
      return _results;
    })()).sort(), ['Jonathan', 'Richard'], 'Combines values correctly');
    return equals(Map.To(Set).Using(Set.union), Map.To(Set).Using(Set.union), 'Map.Using cached correctly');
  });
  module('Stream');
  test('Stream::add', function() {
    var output1, output2, stream;
    stream = new Stream();
    output1 = [];
    output2 = [];
    stream.each(function() {
      return output1.push(this);
    });
    stream.each(function() {
      return output2.push("<" + this + ">");
    });
    stream.add('red').add('green').add('blue');
    deepEqual(output1, ['red', 'green', 'blue'], 'Items added to stream are passed to each');
    return deepEqual(output2, ['<red>', '<green>', '<blue>'], 'Allows multiple each callbacks');
  });
  test('Stream.Of', function() {
    var Person, PersonStream1, PersonStream2, fred, john, output, stream;
    Person = function(name) {
      this.name = name;
    };
    stream = new (Stream.Of(Person));
    output = [];
    stream.each(function(person) {
      return output.push(person);
    });
    stream.add(new Person('fred')).add('john');
    fred = output[0], john = output[1];
    equal(stream instanceof Stream, true, 'Typed Streams are Streams');
    equal(fred instanceof Person && john instanceof Person, true, 'Objects in stream are of correct type');
    equal(john.name, 'john', 'Passes arguments to constructors correctly');
    PersonStream1 = Stream.Of(Person);
    PersonStream2 = Stream.Of(Person);
    return equal(PersonStream1, PersonStream2, 'Typed Stream constructor cached correctly');
  });
  test('Stream::map', function() {
    var output, stream;
    stream = new Stream();
    output = [];
    stream.map(function() {
      return 1 === this.mod(2);
    }).each(function(item) {
      return output.push(item);
    });
    stream.add(1).add(2).add(3).add(4).add(5).add(6);
    return deepEqual(output, [true, false, true, false, true, false], 'Correctly applies map');
  });
  test('Stream::where', function() {
    var output1, output2, stream;
    stream = new Stream();
    output1 = [];
    output2 = [];
    stream.each(function() {
      return output1.push(this);
    });
    stream.where(function() {
      return 1 === this.mod(2);
    }).each(function() {
      return output2.push(this);
    });
    stream.add(1).add(2).add(3).add(4).add(5).add(6);
    deepEqual(output1, [1, 2, 3, 4, 5, 6], 'Behaviour of base stream is unaffected');
    return deepEqual(output2, [1, 3, 5], 'Derived stream only includes first n items');
  });
  test('Stream::take', function() {
    var output1, output2, stream;
    stream = new Stream();
    output1 = [];
    output2 = [];
    stream.each(function() {
      return output1.push(this);
    });
    stream.take(3).each(function() {
      return output2.push(this);
    });
    stream.add('red').add('green').add('blue').add('cyan').add('magenta').add('yellow');
    deepEqual(output1, ['red', 'green', 'blue', 'cyan', 'magenta', 'yellow'], 'Behaviour of base stream is unaffected');
    return deepEqual(output2, ['red', 'green', 'blue'], 'Derived stream only includes first n items');
  });
  test('Stream::drop', function() {
    var output1, output2, stream;
    stream = new Stream();
    output1 = [];
    output2 = [];
    stream.each(function() {
      return output1.push(this);
    });
    stream.drop(3).each(function() {
      return output2.push(this);
    });
    stream.add('red').add('green').add('blue').add('cyan').add('magenta').add('yellow');
    deepEqual(output1, ['red', 'green', 'blue', 'cyan', 'magenta', 'yellow'], 'Behaviour of base stream is unaffected');
    return deepEqual(output2, ['cyan', 'magenta', 'yellow'], 'Derived stream does not include first n items');
  });
  test('Stream::transition', function() {
    var output, stream;
    stream = new Stream();
    output = [];
    stream.transition().each(function() {
      return output.push(this);
    });
    stream.add(3).add(3).add(3).add(2).add(5).add(5).add(1);
    deepEqual(output, [3, 2, 5, 1], 'Transition stream only contains distinct values');
    output = [];
    stream.add(false).add(false).add(false).add(true).add(false).add(true).add(true);
    return deepEqual(output, [false, true, false, true], 'Transition works for Boolean values');
  });
  test('Stream::control', function() {
    var control, data, output;
    data = new Stream();
    control = new Stream();
    output = [];
    data.control(control).each(function() {
      return output.push(this);
    });
    data.add('red');
    data.add('green');
    control.add(false);
    data.add('blue');
    data.add('cyan');
    control.add(true);
    data.add('magenta');
    control.add(false);
    data.add('yellow');
    return deepEqual(output, ['red', 'green', 'magenta'], 'Control stream gates output');
  });
  test('Stream::between', function() {
    var data, output, start, stop;
    data = new Stream();
    start = new Stream();
    stop = new Stream();
    output = [];
    data.between(start, stop).each(function() {
      return output.push(this);
    });
    data.add('red');
    data.add('green');
    stop.add(16);
    data.add('blue');
    data.add('cyan');
    start.add('fred');
    start.add('smith');
    data.add('magenta');
    stop.add(false);
    data.add('yellow');
    return deepEqual(output, ['red', 'green', 'magenta'], 'Start and stop streams open and close gate');
  });
  test('Stream::accumulate', function() {
    var numbers, output;
    numbers = new Stream();
    output = [];
    numbers.accumulate(Math.plus).each(function() {
      return output.push(this);
    });
    numbers.add(1).add(2).add(3).add(4).add(5).add(6);
    deepEqual(output, [1, 3, 6, 10, 15, 21], 'Accumulates correctly');
    numbers = new Stream();
    output = [];
    numbers.accumulate(Math.plus, 10).each(function() {
      return output.push(this);
    });
    numbers.add(1).add(2).add(3).add(4).add(5).add(6);
    return deepEqual(output, [11, 13, 16, 20, 25, 31], 'Starts with initial value');
  });
  test('Stream.disjoin', function() {
    var colours1, colours2, output;
    colours1 = new Stream();
    colours2 = new Stream();
    output = [];
    Stream.disjoin(colours1, colours2).each(function() {
      return output.push(this);
    });
    colours1.add('red');
    colours2.add('cyan');
    colours1.add('green');
    colours2.add('magenta');
    colours1.add('blue');
    colours2.add('yellow');
    return deepEqual(output, ['red', 'cyan', 'green', 'magenta', 'blue', 'yellow'], 'Correctly disjoins streams');
  });
  module('Record');
  test('Constructor', function() {
    var Person, Person2, einstein, org;
    Person = Record.Of({
      name: String,
      dob: Date,
      affiliations: Set.Of(String)
    });
    einstein = new Person({
      name: 'Albert Einstein',
      dob: '1879-3-14',
      affiliations: ['Swiss Patent Office', 'Insititute for Advanced Study']
    });
    equals(typeof einstein.name() === 'string', true, 'Creates string fields of correct type');
    equals(einstein.name(), 'Albert Einstein', 'Creates string fields with correct value');
    equals(einstein.dob() instanceof Date, true, 'Creates date fields of correct type');
    equals(einstein.dob().toDateString(), 'Fri Mar 14 1879', 'Creates string fields with correct value');
    equals(einstein.affiliations() instanceof Set, true, 'Creates composite fields of correct type');
    deepEqual((function() {
      var _i, _len, _ref, _results;
      _ref = einstein.affiliations();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        org = _ref[_i];
        _results.push(org);
      }
      return _results;
    })(), ['Swiss Patent Office', 'Insititute for Advanced Study'], 'Passes correct constructor arguments');
    einstein.name('Al Einstein');
    equals(einstein.name(), 'Al Einstein', true, 'String fields can be updated');
    einstein.name(function(name) {
      return "" + name + " rules!";
    });
    equals(einstein.name(), 'Al Einstein rules!', true, 'String fields allow functional updates');
    Person2 = Record.Of({
      name: String,
      dob: Date,
      affiliations: Set.Of(String)
    });
    return equals(Person, Person2, 'Record.Of caches correctly');
  });
  module('Event');
  module('Subscriber');
  module('EventType');
  delay = function(fn) {
    return setTimeout(fn, 50);
  };
  test('EventType::subscribe', function() {
    var et, subscriber;
    et = new EventType();
    subscriber = new Subscriber();
    et.subscribe(subscriber);
    return equal(et.subscribers[0], subscriber, 'Subscribers are added to subscriber set');
  });
  asyncTest('EventType::add', 1, function() {
    var et, output, promise1, promise2;
    et = new EventType();
    output = [];
    promise1 = new Promise();
    promise2 = new Promise();
    et.subscribe(function(x) {
      return output.push(x);
    });
    et.add(promise1);
    et.add(promise2);
    promise1.fulfil('red');
    promise2.fulfil('green');
    return delay(function() {
      deepEqual(output, ['red', 'green'], 'Raising notifies first subscriber');
      return start();
    });
  });
  asyncTest('EventType::raise', 2, function() {
    var et, output1, output2;
    et = new EventType();
    output1 = [];
    output2 = [];
    et.subscribe(function(x) {
      return output1.push(x);
    });
    et.subscribe(function(x) {
      return output2.push(x);
    });
    et.raise('red');
    et.raise('green');
    return delay(function() {
      deepEqual(output1, ['red', 'green'], 'Raising notifies first subscriber');
      deepEqual(output2, ['red', 'green'], 'Raising notifies other subscribers');
      return start();
    });
  });
  asyncTest('EventType::where', 1, function() {
    var numbers, output;
    numbers = new EventType();
    output = [];
    numbers.where(function() {
      return this % 2 === 0;
    }).subscribe(function(x) {
      return output.push(x);
    });
    numbers.raise(1);
    numbers.raise(2);
    numbers.raise(3);
    numbers.raise(4);
    return delay(function() {
      console.log(output[0]);
      deepEqual(output, [2, 4], 'Derived events notify correctly');
      return start();
    });
  });
  asyncTest('EventType.Of', 0, function() {
    var ValueChangeEvent, et;
    ValueChangeEvent = function(value, old) {
      this.value = value;
      this.old = old;
    };
    et = new (EventType.Of(ValueChangeEvent));
    et.subscribe(function(event) {
      equal(event instanceof ValueChangeEvent, true, 'Generates events of right type');
      deepEqual([event.value, event.old], ['red', 'green'], 'Passes correct values to constructor');
      return start();
    });
    return et.raise('red', 'green');
  });
  module('EventRegistry');
  module('Observable');
  asyncTest('(Observable Set)::add', 1, function() {
    var items, set;
    delay = function(fn) {
      return setTimeout(fn, 1);
    };
    set = new (Observable(Set));
    items = [];
    set.event('add').subscribe(function(item) {
      return items.push(item);
    });
    set.add(1).add(1).add(2).add(3).add(2).add(4).add(1).add(5).add(6);
    return delay(function() {
      deepEqual(items, [1, 2, 3, 4, 5, 6], 'Raises correct events on addition');
      return start();
    });
  });
  asyncTest('(Observable Set)::remove', 1, function() {
    var items, set;
    delay = function(fn) {
      return setTimeout(fn, 1);
    };
    set = new (Observable(Set))([1, 2, 3, 4, 5, 6]);
    items = [];
    set.event('remove').subscribe(function(item) {
      return items.push(item);
    });
    set.remove(Number.Odd.valid);
    return delay(function() {
      deepEqual(items, [1, 3, 5], 'Raises correct events on addition');
      return start();
    });
  });
  asyncTest('(Observable List)::add', 1, function() {
    var items, list;
    delay = function(fn) {
      return setTimeout(fn, 1);
    };
    list = new (Observable(List));
    items = [];
    list.event('add').subscribe(function(item) {
      return items.push(item);
    });
    list.add(1).add(1).add(2).add(3).add(2).add(4).add(1).add(5).add(6);
    return delay(function() {
      deepEqual(items, [1, 1, 2, 3, 2, 4, 1, 5, 6], 'Raises correct events on addition');
      return start();
    });
  });
  asyncTest('(Observable Map)::add', 1, function() {
    var map, mappings;
    delay = function(fn) {
      return setTimeout(fn, 1);
    };
    map = new (Observable(Map));
    mappings = [];
    map.event('add').subscribe(function(key, value) {
      return mappings.push("" + key + "->" + value);
    });
    map.add({
      up: 'quark',
      down: 'quark',
      electron: 'lepton',
      neutrino: 'lepton'
    });
    return delay(function() {
      deepEqual(mappings, ['up->quark', 'down->quark', 'electron->lepton', 'neutrino->lepton'], 'Raises correct events on addition');
      return start();
    });
  });
  return asyncTest('(Observable Map)::remove', 1, function() {
    var map, removed;
    delay = function(fn) {
      return setTimeout(fn, 1);
    };
    map = new (Observable(Map));
    removed = [];
    map.event('remove').subscribe(function(key) {
      return removed.push(key);
    });
    map.add({
      up: 'quark',
      down: 'quark',
      electron: 'lepton',
      neutrino: 'lepton'
    });
    map.remove('up');
    map.remove('electron');
    return delay(function() {
      deepEqual(removed, ['up', 'electron'], 'Raises correct events on removal');
      return start();
    });
  });
});

//# sourceMappingURL=test-library.map
